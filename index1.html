<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FateFinder AI Chat Debug</title>
    
    <style>
        /* è¯·åœ¨ CSS å—çš„é¡¶éƒ¨æ·»åŠ è¿™ä¸ªå…¨å±€è§„åˆ™ï¼Œä»¥ç¡®ä¿æ‰€æœ‰å…ƒç´ éƒ½éµå¾ªç°ä»£æ¨¡å‹ */
    *,
    *::before,
    *::after {
        box-sizing: border-box;
    }
    
    /* æˆ–è€…ï¼Œæ‚¨åªé’ˆå¯¹å¼¹çª—å†…å®¹æ·»åŠ  */
    .modal-content {
        /* ä¿æŒåŸæœ‰çš„æ ·å¼... */
        box-sizing: border-box; /* å¼ºåˆ¶å°† padding å’Œ border åŒ…å«åœ¨ width å†… */
    }
        
        /* å®¹å™¨å’Œå¸ƒå±€æ ·å¼ */
        #ai-chat-container-wrapper {
            width: 100%; 
            max-width: 700px;
            margin: 0 auto;
            padding: 20px 0;
            color: #e0e0e0;
            font-family: Arial, sans-serif;
        }
    
        #chat-container {
            background: rgba(30, 30, 30, 0.95) !important;
            border-radius: 10px !important;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5) !important;
            width: 100% !important;
            padding: 20px !important;
            display: flex !important;
            flex-direction: column !important;
            position: relative !important;
            z-index: 1 !important;
            border: 1px solid #404040 !important;
            pointer-events: auto !important;
            height: 600px !important;
            max-height: 600px !important;
            overflow: hidden !important;
        }
    
        #chat-box {
            flex: 1 1 auto; 
            min-height: 0;
            padding: 10px;
            overflow-y: auto !important;
            overflow-x: hidden !important;
            border: 1px solid #404040;
            border-radius: 5px;
            margin-bottom: 20px;
            background: #1a1a1a;
            color: #e0e0e0;
        }
    
        /* æ»šåŠ¨æ¡æ ·å¼ */
        #chat-box::-webkit-scrollbar, #options::-webkit-scrollbar { width: 8px; }
        #chat-box::-webkit-scrollbar-track, #options::-webkit-scrollbar-track { background: #1a1a1a; }
        #chat-box::-webkit-scrollbar-thumb, #options::-webkit-scrollbar-thumb { background: #404040; border-radius: 4px; }
        #chat-box::-webkit-scrollbar-thumb:hover, #options::-webkit-scrollbar-thumb:hover { background: #555555; }
        
        /* è¾“å…¥ç»„å’ŒæŒ‰é’®æ ·å¼ */
        #input-group { display: none; flex-direction: column; gap: 10px; margin-bottom: 20px; padding: 10px; border-top: 1px solid #404040; background-color: #1a1a1a; align-items: center; flex-shrink: 0; }
        #birthday-input { flex: 1; height: 20px; padding: 10px; border: 1px solid #404040; border-radius: 4px; margin-left: 50px; margin-right: 10px; background-color: #2d2d2d; color: #e0e0e0; }
        #birthday-input:focus { outline: none; border-color: #5a9; }
        #send-button { height: 40px; margin-left: 10px; padding: 10px 20px; border: none; background-color: #5a9; color: #ffffff; border-radius: 4px; cursor: pointer; margin-right: 50px; }
        #send-button:hover { background-color: #6bb; }
    
        /* é€‰é¡¹æ ·å¼ */
        #options { display: flex; flex-direction: column; flex-wrap: wrap; justify-content: center; gap: 10px; max-height: 200px; overflow-y: auto; scroll-behavior: smooth; padding: 10px; border: 1px solid #404040; background: #1a1a1a; flex-shrink: 0; }
        #options button { margin: 5px; padding: 10px 20px; border: none; border-radius: 4px; cursor: pointer; background-color: #2d4a5a; color: #e0e0e0; }
        #options button:hover { background-color: #3d5a6a; }
    
        /* æ¶ˆæ¯æ ·å¼ */
        .message { display: flex; align-items: center; margin: 5px 0; padding: 10px; border-radius: 5px; max-width: 80%; color: #e0e0e0; clear: both; }
        .message.bot { background-color: rgba(90, 153, 153, 0.3); align-self: flex-start; border: 1px solid rgba(90, 153, 153, 0.5); }
        .message.user { background-color: #2d4a5a; align-self: flex-end; color: #e0e0e0; border: 1px solid #3d5a6a; }
        
        /* æ¨¡æ€æ¡†å’Œå·¥å…·æç¤º */
        .modal { display: none; position: fixed; z-index: 9999; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.7); }
        .modal-content { background-color: #2d2d2d; margin: 15% auto; padding: 20px; border: 1px solid #404040; width: 300px; text-align: center; color: #e0e0e0; border-radius: 8px; }
        .modal-content p { color: #e0e0e0; }
        .tooltip { display: none; position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%); background: rgba(45, 74, 90, 0.9); color: #e0e0e0; padding: 10px; border-radius: 5px; font-size: 14px; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3); border: 1px solid #5a9; }
    
        /* å…¶ä»–æ ·å¼ (Thinking, Media Queries) */
        .thinking { display: flex; align-items: center; justify-content: center; margin: 10px 0; }
        .thinking span { width: 8px; height: 8px; margin: 0 2px; background-color: #5a9; border-radius: 50%; display: inline-block; animation: bounce 1.1s infinite both; }
        .thinking span:nth-child(1) { animation-delay: -0.32s; }
        .thinking span:nth-child(2) { animation-delay: -0.16s; }
        @keyframes bounce { 0%, 80%, 100% { transform: scale(0); } 40% { transform: scale(1); } }
        /* å“åº”å¼è®¾è®¡ */
        @media only screen and (orientation: portrait) { #chat-container { width: 90%; height: 90%; } #chat-box { padding: 10px; max-height: calc(100vh - 150px); } #input-group { padding: 5px; } #options button { padding: 8px 16px; } }
        @media only screen and (orientation: landscape) { #chat-container { width: 60%; height: 80%; } #chat-box { padding: 10px; max-height: calc(100vh - 150px); } #input-group { padding: 5px; } #options button { padding: 8px 16px; } }
    </style>
    
</head>
<body>
    <div id="ai-chat-container-wrapper">
        <div id="chat-container">
            <div id="chat-box"></div>
            <div id="input-group">
                <input type="datetime-local" id="birthday-input" placeholder="Enter your date and time of birth">
                <button id="send-button">Submit</button>
            </div>
            <div id="tooltip" class="tooltip">Swipe Left for More...</div>
            <div id="options"></div>
            <div id="deepseek-chat-group" style="display: none; flex-direction: column; gap: 10px; margin-top: 10px; padding: 10px; border-top: 1px solid #404040; background-color: #1a1a1a; flex-shrink: 0;">
                <div style="display: flex; gap: 10px; align-items: center;">
                    <input type="text" id="deepseek-input" placeholder="Ask DeepSeek anything..." style="flex: 1; padding: 8px; border: 1px solid #404040; border-radius: 4px; background-color: #2d2d2d; color: #e0e0e0;">
                    <button id="deepseek-send-btn" style="padding: 8px 15px; border: none; background-color: #5a9; color: #ffffff; border-radius: 4px; cursor: pointer;">Send</button>
                </div>
            </div>
            <div id="genderModal" class="modal">
                <div class="modal-content">
                    <p>To provide a more accurate answer to your query, please enter the gender you were assigned at birth:</p>
                    <button id="maleButton">Male</button>
                    <button id="femaleButton">Female</button>
                </div>
            </div>
        </div>
        </div>

    <script>
        (
    function() 
    {
        // --- START: HOISTED CORE UI FUNCTIONS (THE FIX) ---
        function appendMessage(text, sender) { 
            console.log("LOG: Function appendMessage called. Sender:", sender);
            const chatBox = document.getElementById('chat-box');
            
            if (!chatBox) {
                console.error("CRITICAL ERROR: chatBox element not found in appendMessage. Cannot append message.");
                return;
            }
    
            const messageElement = document.createElement('div');
            messageElement.className = `message ${sender}`;
            messageElement.textContent = text;
            chatBox.appendChild(messageElement);
            console.log("LOG: Message element appended to chatBox.");
    
            chatBox.scrollTop = chatBox.scrollHeight;
        }
        function displayResponseGradually(responseOrigin) { 
            console.log("LOG: Function displayResponseGradually called with:", responseOrigin);
            if (!responseOrigin) {
                console.error("LOG: displayResponseGradually received undefined or null response");
                appendMessage('Error: Unable to generate response. Please try again.', 'bot');
                return;
            }
            const response = String(responseOrigin).replace(/\n/g, '<br>');
            const chatBox = document.getElementById('chat-box');
            const message = document.createElement('div');
            message.classList.add('message', 'bot');
            chatBox.appendChild(message);
    
            let index = 0;
            const interval = setInterval(() => {
                message.innerHTML = `<p>${response.slice(0, index)}</p>`;
                chatBox.scrollTop = chatBox.scrollHeight;
                index++;
                if (index > response.length) clearInterval(interval);
            }, 50);
        }
        function showInputGroup() {
            console.log("LOG: Function showInputGroup called.");
            const inputGroup = document.getElementById('input-group');
            if (!inputGroup) {
                 console.error("CRITICAL ERROR: inputGroup element not found in showInputGroup.");
                 return;
            }
            
            inputGroup.style.display = 'flex';
            
            const birthdayInput = document.getElementById('birthday-input');
            if(birthdayInput) {
                 birthdayInput.focus();
            } else {
                 console.error("ERROR: birthdayInput element not found.");
            }
        }
        function sendMessage(event) {
            console.log("LOG: Function sendMessage called.");
            const birthdayInput = document.getElementById('birthday-input');
            const birthdayMessage = birthdayInput.value.trim();
            if (!birthdayMessage) {
                appendMessage('Please enter a valid date and time of birth.', 'bot');
                return;
            }
    
            // Save birthday globally
            userInteraction.birthday = birthdayMessage;
            console.log("LOG: Birthday saved to userInteraction:", userInteraction.birthday);
            
            // Save to localStorage for persistence (even if gender is not set yet)
            saveUserBirthdayGender(birthdayMessage, userInteraction.gender);
            
            // Update Bazi calculation with the new birthday
            updateBaziZodiac();
            
            birthdayInput.value = '';
            document.getElementById('input-group').style.display = 'none';
            appendMessage(`Your birthday has been saved: ${birthdayMessage}`, 'user');
            loadCategories();
        }
        // --- END: HOISTED CORE UI FUNCTIONS ---
        
        // --- START: LUNA.JS ---
        class Lunar { 
            constructor(date) {
                if (!date) {
                    date = new Date();
                }
                this.init(date.getTime());
            }
            // ... (Full Lunar class content continues) ...
            static lunarInfo = [
                0x4bd8, 0x4ae0, 0xa570, 0x54d5, 0xd260, 0xd950, 0x5554, 0x56af,
                0x9ad0, 0x55d2, 0x4ae0, 0xa5b6, 0xa4d0, 0xd250, 0xd295, 0xb54f,
                0xd6a0, 0xada2, 0x95b0, 0x4977, 0x497f, 0xa4b0, 0xb4b5, 0x6a50,
                0x6d40, 0xab54, 0x2b6f, 0x9570, 0x52f2, 0x4970, 0x6566, 0xd4a0,
                0xea50, 0x6a95, 0x5adf, 0x2b60, 0x86e3, 0x92ef, 0xc8d7, 0xc95f,
                0xd4a0, 0xd8a6, 0xb55f, 0x56a0, 0xa5b4, 0x25df, 0x92d0, 0xd2b2,
                0xa950, 0xb557, 0x6ca0, 0xb550, 0x5355, 0x4daf, 0xa5b0, 0x4573,
                0x52bf, 0xa9a8, 0xe950, 0x6aa0, 0xaea6, 0xab50, 0x04b60, 0xaae4,
                0xa570, 0x5260, 0xf263, 0xd950, 0x5b57, 0x56a0, 0x96d0, 0x4dd5,
                0x4ad0, 0xa4d0, 0xd4d4, 0xd250, 0xd558, 0xb540, 0xb6a0, 0x95a6,
                0x95bf, 0x49b0, 0xa974, 0xa4b0, 0xb27a, 0x6a50, 0x6d40, 0xaf46,
                0xab60, 0x9570, 0x4af5, 0x4970, 0x64b0, 0x74a3, 0xea50, 0x6b58,
                0x5ac0, 0xab60, 0x96d5, 0x92e0, 0xc960, 0xd954, 0xd4a0, 0xda50,
                0x7552, 0x56a0, 0xabb7, 0x025d0, 0x92d0, 0xcab5, 0xa950, 0xb4a0,
                0xbaa4, 0xad50, 0x55d9, 0x4ba0, 0xa5b0, 0x5176, 0x52bf, 0xa930,
                0x7954, 0x6aa0, 0xad50, 0x5b52, 0x4b60, 0xa6e6, 0xa4e0, 0xd260,
                0xea65, 0xd530, 0x5aa0, 0x76a3, 0x96d0, 0x4afb, 0x4ad0, 0xa4d0,
                0xd0b6, 0xd25f, 0xd520, 0xdd45, 0xb5a0, 0x56d0, 0x55b2, 0x49b0,
                0xa577, 0xa4b0, 0xaa50, 0xb255, 0x6d2f, 0xada0, 0x4b63, 0x937f,
                0x49f8, 0x4970, 0x64b0, 0x68a6, 0xea5f, 0x6b20, 0xa6c4, 0xaaef,
                0x92e0, 0xd2e3, 0xc960, 0xd557, 0xd4a0, 0xda50, 0x5d55, 0x56a0,
                0xa6d0, 0x55d4, 0x52d0, 0xa9b8, 0xa950, 0xb4a0, 0xb6a6, 0xad50,
                0x55a0, 0xaba4, 0xa5b0, 0x52b0, 0xb273, 0x6930, 0x7337, 0x6aa0,
                0xad50, 0x4b55, 0x4b6f, 0xa570, 0x54e4, 0xd260, 0xe968, 0xd520,
                0xdaa0, 0x6aa6, 0x56df, 0x4ae0, 0xa9d4, 0xa4d0, 0xd150, 0xf252, 0xd520
            ];
            
            static solarTermInfo = [ /* ... */ ];
            static Tianan = ["ç”²", "ä¹™", "ä¸™", "ä¸", "æˆŠ", "å·±", "åºš", "è¾›", "å£¬", "ç™¸"];
            static Deqi = ["å­", "ä¸‘", "å¯…", "å¯", "è¾°", "å·³", "åˆ", "æœª", "ç”³", "é…‰", "æˆŒ", "äº¥"];
            static Animals = ["é¼ ", "ç‰›", "è™", "å…”", "é¾™", "è›‡", "é©¬", "ç¾Š", "çŒ´", "é¸¡", "ç‹—", "çŒª"];
            static solarTerm = ["å°å¯’", "å¤§å¯’", "ç«‹æ˜¥", "é›¨æ°´", "æƒŠè›°", "æ˜¥åˆ†", "æ¸…æ˜", "è°·é›¨", "ç«‹å¤", "å°æ»¡", "èŠ’ç§", "å¤è‡³", "å°æš‘", "å¤§æš‘", "ç«‹ç§‹", "å¤„æš‘", "ç™½éœ²", "ç§‹åˆ†", "å¯’éœ²", "éœœé™", "ç«‹å†¬", "å°é›ª", "å¤§é›ª", "å†¬è‡³"];
            static lunarString1 = ["é›¶", "ä¸€", "äºŒ", "ä¸‰", "å››", "äº”", "å…­", "ä¸ƒ", "å…«", "ä¹"];
            static lunarString2 = ["åˆ", "å", "å»¿", "å…", "æ­£", "è…Š", "å†¬", "é—°"];
    
            static getLunarLeapMonth(lunarYear) { /* ... */ return (lunarYear - 1900) & 0xf; }
            // ... (Remaining methods of Lunar class) ...
            init(TimeInMillis) { /* ... */ }
            getCyclicalData() { /* ... */ }
            getAnimalString() { /* ... */ }
            getTermString() { /* ... */ }
            getCyclicalDateString() { /* ... */ }
            getCyclicaYear() { /* ... */ }
            getCyclicaMonth() { /* ... */ }
            getCyclicaDay() { /* ... */ }
            getLunarDayString() { /* ... */ }
            getLunarMonthString() { /* ... */ }
            getLunarYearString() { /* ... */ }
            getLunarDateString() { /* ... */ }
        }
        // --- END: LUNA.JS ---
    
        // --- START: BAZI.JS ---
        const chineseNumber = ["æ­£", "äºŒ", "ä¸‰", "å››", "äº”", "å…­", "ä¸ƒ", "å…«", "ä¹", "å", "åä¸€", "è…Š"];
        const Gan = ["ç”²", "ä¹™", "ä¸™", "ä¸", "æˆŠ", "å·±", "åºš", "è¾›", "å£¬", "ç™¸"];
        const Zhi = ["å­", "ä¸‘", "å¯…", "å¯", "è¾°", "å·³", "åˆ", "æœª", "ç”³", "é…‰", "æˆŒ", "äº¥"];
        const lunarInfo = [
            0x04bd8, 0x04ae0, 0x0a570, 0x054d5, 0x0d260, 0x0d950, 0x16554, 0x056a0, 0x09ad0, 0x055d2,
            0x04ae0, 0x0a5b6, 0x0a4d0, 0x0d250, 0x1d255, 0x0b540, 0x0d6a0, 0x0ada2, 0x095b0, 0x14977,
            0x04970, 0x0a4b0, 0x0b4b5, 0x06a50, 0x06d40, 0x1ab54, 0x02b60, 0x09570, 0x052f2, 0x04970,
            0x06566, 0x0d4a0, 0x0ea50, 0x06e95, 0x05ad0, 0x02b60, 0x186e3, 0x092e0, 0x1c8d7, 0x0c950,
            0x0d4a0, 0x1d8a6, 0x0b550, 0x056a0, 0x1a5b4, 0x025d0, 0x092d0, 0x0d2b2, 0x0a950, 0x0b557,
            0x06ca0, 0x0b550, 0x15355, 0x04da0, 0x0a5d0, 0x14573, 0x052d0, 0x0a9a8, 0x0e950, 0x06aa0,
            0x0aea6, 0x0ab50, 0x04b60, 0x0aae4, 0x0a570, 0x05260, 0x0f263, 0x0d950, 0x05b57, 0x056a0,
            0x096d0, 0x04dd5, 0x04ad0, 0x0a4d0, 0x0d4d4, 0x0d250, 0x0d558, 0x0b540, 0x0b5a0, 0x195a6,
            0x095b0, 0x049b0, 0x0a974, 0x0a4b0, 0x0b27a, 0x06a50, 0x06d40, 0x0af46, 0x0ab60, 0x09570,
            0x04af5, 0x04970, 0x064b0, 0x074a3, 0x0ea50, 0x06b58, 0x055c0, 0x0ab60, 0x096d5, 0x092e0,
            0x0c960, 0x0d954, 0x0d4a0, 0x0da50, 0x07552, 0x056a0, 0x0abb7, 0x025d0, 0x092d0, 0x0cab5,
            0x0a950, 0x0b4a0, 0x0baa4, 0x0ad50, 0x055d9, 0x04ba0, 0x0a5b0, 0x15176, 0x052b0, 0x0a930,
            0x07954, 0x06aa0, 0x0ad50, 0x05b52, 0x04b60, 0x0a6e6, 0x0a4e0, 0x0d260, 0x0ea65, 0x0d530,
            0x05aa0, 0x076a3, 0x096d0, 0x04bd7, 0x04ad0, 0x0a4d0, 0x1d0b6, 0x0d250, 0x0d520, 0x0dd45,
            0x0b5a0, 0x056d0, 0x055b2, 0x049b0, 0x0a577, 0x0a4b0, 0x0aa50, 0x1b255, 0x06d20, 0x0ada0
        ];
        const chineseDateFormat = new Intl.DateTimeFormat('zh-CN', { year: 'numeric', month: '2-digit', day: '2-digit' });
        
        class BaZi {
            constructor(cal) {
                this.cal = cal;
                this.baseDate = new Date(1900, 0, 31);
                this.init();
            }

            init() {
                let offset = Math.floor((this.cal - this.baseDate) / 86400000);
                let dayCyl = offset + 40;
                let monCyl = 14;

                let iYear, daysOfYear = 0;
                for (iYear = 1900; iYear < 2050 && offset > 0; iYear++) {
                    daysOfYear = this.yearDays(iYear);
                    offset -= daysOfYear;
                    monCyl += 12;
                }
                if (offset < 0) {
                    offset += daysOfYear;
                    iYear--;
                    monCyl -= 12;
                }

                this.year = iYear;
                let yearCyl = iYear - 1864;
                let leapMonth = this.leapMonth(iYear);
                this.leap = false;

                let iMonth, daysOfMonth = 0;
                for (iMonth = 1; iMonth < 13 && offset > 0; iMonth++) {
                    if (leapMonth > 0 && iMonth == (leapMonth + 1) && !this.leap) {
                        --iMonth;
                        this.leap = true;
                        daysOfMonth = this.leapDays(this.year);
                    } else {
                        daysOfMonth = this.monthDays(this.year, iMonth);
                    }
                    offset -= daysOfMonth;
                    if (this.leap && iMonth == (leapMonth + 1)) {
                        this.leap = false;
                    }
                    if (!this.leap) {
                        monCyl++;
                    }
                }

                if (offset == 0 && leapMonth > 0 && iMonth == leapMonth + 1) {
                    if (this.leap) {
                        this.leap = false;
                    } else {
                        this.leap = true;
                        --iMonth;
                        --monCyl;
                    }
                }

                if (offset < 0) {
                    offset += daysOfMonth;
                    --iMonth;
                    --monCyl;
                }

                this.month = iMonth;
                this.day = offset + 1;
            }

            yearDays(year) {
                let sum = 348;
                for (let i = 0x8000; i > 0x8; i >>= 1) {
                    if ((lunarInfo[year - 1900] & i) !== 0) sum += 1;
                }
                return sum + this.leapDays(year);
            }

            leapDays(year) {
                if (this.leapMonth(year) !== 0) {
                    if ((lunarInfo[year - 1900] & 0x10000) !== 0) {
                        return 30;
                    } else {
                        return 29;
                    }
                } else {
                    return 0;
                }
            }

            leapMonth(year) {
                return lunarInfo[year - 1900] & 0xf;
            }

            monthDays(year, month) {
                if ((lunarInfo[year - 1900] & (0x10000 >> month)) === 0) {
                    return 29;
                } else {
                    return 30;
                }
            }

            getYear() {
                return this.getYearStr(this.year);
            }

            getMonth() {
                return chineseNumber[this.month - 1];
            }

            getDay() {
                return this.getChinaDayString(this.day);
            }

            getYearGanZhi(hour) {
                let idx = (this.year - 1864) % 60;
                const y = BaZi.jiazhi[idx];

                idx = idx % 5;
                const idxm = (idx + 1) * 2 % 10;
                const m = Gan[(idxm + this.month - 1) % 10] + Zhi[(this.month + 2 - 1) % 12];

                const offset = (Math.floor((this.cal - this.baseDate) / 86400000) + 40) % 60;
                const d = BaZi.jiazhi[offset];

                const h = Gan[(offset % 5 * 2 + hour) % 10] + Zhi[hour % 12];
                return `${y},${m},${d},${h}`;
            }

            animalsYear() {
                const Animals = ["é¼ ", "ç‰›", "è™", "å…”", "é¾™", "è›‡", "é©¬", "ç¾Š", "çŒ´", "é¸¡", "ç‹—", "çŒª"];
                return Animals[(this.year - 4) % 12];
            }

            getYearStr(year) {
                const chineseword = ["é›¶", "ä¸€", "äºŒ", "ä¸‰", "å››", "äº”", "å…­", "ä¸ƒ", "å…«", "ä¹"];
                let ys = "";
                ys += chineseword[Math.floor(year / 1000)];
                year %= 1000;
                ys += chineseword[Math.floor(year / 100)];
                year %= 100;
                ys += chineseword[Math.floor(year / 10)];
                year %= 10;
                ys += chineseword[year];
                return ys;
            }

            getChinaDayString(day) {
                const chineseTen = ["åˆ", "å", "å»¿", "å…"];
                const n = day % 10 === 0 ? 9 : day % 10 - 1;
                if (day > 30) return "";
                if (day === 10) return "åˆå";
                return chineseTen[Math.floor(day / 10)] + chineseNumber[n];
            }

            toString() {
                return `${this.getYearStr(this.year)}å¹´${this.leap ? "é—°" : ""}${chineseNumber[this.month - 1]}æœˆ${this.getChinaDayString(this.day)}`;
            }
        }
        
        BaZi.jiazhi = [
            "ç”²å­", "ä¹™ä¸‘", "ä¸™å¯…", "ä¸å¯", "æˆŠè¾°", "å·±å·³", "åºšåˆ", "è¾›æœª", "å£¬ç”³", "ç™¸é…‰",
            "ç”²æˆŒ", "ä¹™äº¥", "ä¸™å­", "ä¸ä¸‘", "æˆŠå¯…", "å·±å¯", "åºšè¾°", "è¾›å·³", "å£¬åˆ", "ç™¸æœª",
            "ç”²ç”³", "ä¹™é…‰", "ä¸™æˆŒ", "ä¸äº¥", "æˆŠå­", "å·±ä¸‘", "åºšå¯…", "è¾›å¯", "å£¬è¾°", "ç™¸å·³",
            "ç”²åˆ", "ä¹™æœª", "ä¸™ç”³", "ä¸é…‰", "æˆŠæˆŒ", "å·±äº¥", "åºšå­", "è¾›ä¸‘", "å£¬å¯…", "ç™¸å¯",
            "ç”²è¾°", "ä¹™å·³", "ä¸™åˆ", "ä¸æœª", "æˆŠç”³", "å·±é…‰", "åºšæˆŒ", "è¾›äº¥", "å£¬å­", "ç™¸ä¸‘",
            "ç”²å¯…", "ä¹™å¯", "ä¸™è¾°", "ä¸å·³", "æˆŠåˆ", "å·±æœª", "åºšç”³", "è¾›é…‰", "å£¬æˆŒ", "ç™¸äº¥"
        ];
        // --- END: BAZI.JS ---
    
        // --- START: PAIPANFINAL.JS ---
        class PaiPanFinal {
            constructor() {
                
            }

            getBazi(cal, isman) {
                let lunar = new BaZi(cal);
                let lunaryue = new Lunar(cal);
                let result = Array(10).fill("");
                let time = Math.floor(cal.getHours() / 2);

                // è·å–ç”Ÿè‚–
                let GanZhi = lunar.getYearGanZhi(time); // å–å…«å­—
                console.log("ganzhi:",GanZhi);
                let tempchar = GanZhi.split(",");
                let ganziyear = tempchar[0]; // å¹´æŸ±
                let ganzimonth = tempchar[1]; // æœˆæŸ±
                let ganziday = tempchar[2]; // æ—¥æŸ±
                let ganzitime = tempchar[3]; // æ—¶æŸ±

                // ç¤ºä¾‹ç”¨æ³•
                const chineseInput = lunar.animalsYear(); // è¾“å…¥ä¸€ä¸ªä¸­æ–‡çš„ç”Ÿè‚–åç§°
                const englishOutput = translateZodiac(chineseInput);
                console.log(englishOutput); // è¾“å‡º: Dragon
                result[0] = englishOutput ;
                result[1] = ganziyear.charAt(0); // å¹´å¹²
                result[2] = ganziyear.charAt(1); // å¹´æ”¯
                result[3] = ganzimonth.charAt(0); // æœˆå¹²
                result[4] = ganzimonth.charAt(1); // æœˆæ”¯
                result[5] = ganziday.charAt(0); // æ—¥å¹²
                result[6] = ganziday.charAt(1); // æ—¥æ”¯
                result[7] = ganzitime.charAt(0); // æ—¶å¹²
                result[8] = ganzitime.charAt(1); // æ—¶æ”¯

                return result;
            }
        }
        function translateZodiac(chineseZodiac) {
            const zodiacMap = {
                "é¼ ": "Rat",
                "ç‰›": "Ox",
                "è™": "Tiger",
                "å…”": "Rabbit",
                "é¾™": "Dragon",
                "è›‡": "Snake",
                "é©¬": "Horse",
                "ç¾Š": "Goat",
                "çŒ´": "Monkey",
                "é¸¡": "Rooster",
                "ç‹—": "Dog",
                "çŒª": "Pig"
            };

            return zodiacMap[chineseZodiac] || "Unknown zodiac";
        }
        // (SAMPLE CODE DELETED HERE)
        // --- END: PAIPANFINAL.JS ---
    
        // --- START: DEALBAZI.JS ---
        function getTianGanTraits(tianGan) {
            const tianGanTraits = {
                "ç”²": "Strong-willed, upright, and ambitious, like a towering tree. However, can be stubborn, inflexible, and overly aggressive.",
                "ä¹™": "Gentle, adaptable, and creative, like a graceful vine. However, may be indecisive, overly sensitive, and prone to self-doubt.",
                "ä¸™": "Optimistic, enthusiastic, and passionate, like the blazing sun. However, can be impulsive, impatient, and easily frustrated.",
                "ä¸": "Thoughtful, caring, and resourceful, like a lamp in the dark. However, may be overly cautious, overthink, and emotionally vulnerable.",
                "æˆŠ": "Stable, dependable, and protective, like solid walls. However, can be rigid, resistant to change, and overly protective.",
                "å·±": "Empathetic, nurturing, and patient, like the earth. However, may be overly accommodating, lack assertiveness, and prone to self-sacrifice.",
                "åºš": "Resolute, determined, and sharp-minded, like a blade. However, can be harsh, uncompromising, and overly critical.",
                "è¾›": "Delicate, elegant, and meticulous, like fine silver. However, may be overly perfectionistic, hesitant, and lack spontaneity.",
                "å£¬": "Bold, visionary, and dynamic, like a grand river. However, can be restless, overly ambitious, and prone to emotional outbursts.",
                "ç™¸": "Quiet, introspective, and intuitive, like a gentle stream. However, may be overly introverted, avoid confrontation, and lack initiative."
            };
            return tianGanTraits[tianGan] || "Invalid input: Please enter a valid Heavenly Stem character.";
        }
        
        function getDiZhiPersonality(diZhi) {
            const diZhiPersonality = {
                "å­": "Smart, adaptable, and charming, but can be secretive and restless.",
                "ä¸‘": "Hardworking, reliable, and patient, but can be overly cautious and stubborn.",
                "å¯…": "Ambitious, confident, and brave, but may be impulsive and aggressive.",
                "å¯": "Gentle, kind, and artistic, but can be overly sensitive and indecisive.",
                "è¾°": "Charismatic, imaginative, and resourceful, but can be proud and unpredictable.",
                "å·³": "Wise, passionate, and intuitive, but may be jealous and manipulative.",
                "åˆ": "Energetic, enthusiastic, and open-hearted, but can be impatient and reckless.",
                "æœª": "Compassionate, creative, and dependable, but may be shy and overly self-critical.",
                "ç”³": "Clever, versatile, and curious, but can be mischievous and unreliable.",
                "é…‰": "Diligent, detail-oriented, and independent, but may be vain and critical.",
                "æˆŒ": "Loyal, honest, and protective, but can be pessimistic and stubborn.",
                "äº¥": "Compassionate, intuitive, and idealistic, but may be naive and escapist."
            };
            return diZhiPersonality[diZhi] || "Invalid input: Please enter a valid Earthly Branch character.";
        }
        
        function getRiYuanDescription(tianGan) {
            const tianGanMap = {
                "ç”²": "A towering tree under the vast sky",
                "ä¹™": "A winding and graceful vine",
                "ä¸™": "The blazing and radiant sun",
                "ä¸": "A lamp in the dark night",
                "æˆŠ": "Solid walls and sturdy dikes",
                "å·±": "The nurturing earth embracing all",
                "åºš": "A sharp and imposing blade or axe",
                "è¾›": "Delicate and exquisite silver jewelry",
                "å£¬": "A grand and majestic river",
                "ç™¸": "A gentle and quiet flowing stream"
            };
            return tianGanMap[tianGan] || "Invalid input: Please enter a valid Heavenly Stem character.";
        }
        
        function transformGanZhiToWuXing(inputString) {
            const ganMapping = {
                'é‡‘': ['åºš', 'è¾›'],
                'æœ¨': ['ç”²', 'ä¹™'],
                'æ°´': ['å£¬', 'ç™¸'],
                'ç«': ['ä¸™', 'ä¸'],
                'åœŸ': ['æˆŠ', 'å·±']
            };
            const zhiMapping = {
                'é‡‘': ['ç”³', 'é…‰'],
                'æœ¨': ['å¯…', 'å¯'],
                'æ°´': ['å­', 'äº¥'],
                'ç«': ['å·³', 'åˆ'],
                'åœŸ': ['è¾°', 'æˆŒ', 'ä¸‘', 'æœª']
            };
            let result = '';
            for (let char of inputString) {
                if (/^[a-zA-Z]+$/.test(char)) {
                    continue;
                }
                let replaced = false;
                for (let [wuXing, ganList] of Object.entries(ganMapping)) {
                    if (ganList.includes(char)) {
                        result += wuXing;
                        replaced = true;
                        break;
                    }
                }
                if (!replaced) {
                    for (let [wuXing, zhiList] of Object.entries(zhiMapping)) {
                        if (zhiList.includes(char)) {
                            result += wuXing;
                            replaced = true;
                            break;
                        }
                    }
                }
                if (!replaced) {
                    result += char;
                }
            }
            return result;
        }
        
        function determineConfidence(inputString) {
            const conditions = {
                'é‡‘': ['é‡‘', 'åœŸ'],
                'æ°´': ['æ°´', 'é‡‘'],
                'æœ¨': ['æœ¨', 'æ°´'],
                'ç«': ['ç«', 'æœ¨'],
                'åœŸ': ['åœŸ', 'ç«']
            };
            const element4 = inputString[3];
            const element5 = inputString[4];
            const element6 = inputString[5];
            if (element5 && (conditions[element5].includes(element4) || conditions[element5].includes(element6))) {
                return 'a confident';
            } else {
                return 'NOT a confident';
            }
        }
        
        function checkElementInString(element, inputString) {
            if (inputString && inputString.includes(element)) {
                return true;
            } else {
                return false;
            }
        }
        
        function checkCharacterAtPosition(char, inputString, position) {
            if (position < 1 || position > inputString.length) {
                return false;
            }
            const charAtPosition = inputString[position - 1];
            return char === charAtPosition ? true : false;
        }
        
        function analyzeWealth(input) {
            const selfPosition = 5;
            const å…‹åˆ¶å…³ç³» = {
                'é‡‘': 'æœ¨',
                'æ°´': 'ç«',
                'æœ¨': 'åœŸ',
                'ç«': 'é‡‘',
                'åœŸ': 'æ°´'
            };
            if (!input || input.length < selfPosition) {
                return "Unable to analyze wealth - insufficient data.";
            }
            const selfElement = input[selfPosition - 1];
            const wealthElement = å…‹åˆ¶å…³ç³»[selfElement];
            const wealthIndices = input.split('').reduce((indices, char, index) => {
                if (char === wealthElement) indices.push(index + 1);
                return indices;
            }, []);
            let result;
            if (wealthIndices.includes(selfPosition - 1) || wealthIndices.includes(selfPosition + 1)) {
                result = "You highly value wealth.";
            } else if (wealthIndices.length === 0) {
                result = "You don't value wealth at all.";
            } else if ([1, 3].some(i => wealthIndices.includes(i)) && !wealthIndices.includes(2)) {
                result = "You seem to value wealth on the surface, but you don't actually value it.";
            } else if (!wealthIndices.includes(1) && wealthIndices.includes(2)) {
                result = "You don't appear to value wealth, but you actually do.";
            } else {
                result = "You care about wealth, but not that much.";
            }
            return result;
        }
        
        function analyzePurpose(input) {
            const selfPosition = 5;
            const å…‹åˆ¶å…³ç³» = {
                'é‡‘': 'æœ¨',
                'æ°´': 'ç«',
                'æœ¨': 'åœŸ',
                'ç«': 'é‡‘',
                'åœŸ': 'æ°´'
            };
            if (!input || input.length < selfPosition) {
                return "Unable to analyze purpose - insufficient data.";
            }
            const selfElement = input[selfPosition - 1];
            const wealthElement = å…‹åˆ¶å…³ç³»[selfElement];
            const wealthIndices = input.split('').reduce((indices, char, index) => {
                if (char === wealthElement) indices.push(index + 1);
                return indices;
            }, []);
            let result;
            if (wealthIndices.includes(selfPosition - 1) || wealthIndices.includes(selfPosition + 1)) {
                result = "You have a strong sense of purpose.";
            } else if (wealthIndices.length === 0) {
                result = "You have no sense of purpose at all.";
            } else if ([1, 3].some(i => wealthIndices.includes(i)) && !wealthIndices.includes(2)) {
                result = "You seem to prioritize goals on the surface, but deep down, you don't actually value them.";
            } else if (!wealthIndices.includes(1) && wealthIndices.includes(2)) {
                result = "You don't seem to prioritize goals on the surface, but deep down, you do value them.";
            } else {
                result = "You do have sense of purpose, but not that much.";
            }
            return result;
        }
        
        function analyzeOpinion(input) {
            const selfPosition = 5;
            const å°ç”Ÿå…³ç³» = {
                'é‡‘': 'åœŸ',
                'æ°´': 'é‡‘',
                'æœ¨': 'æ°´',
                'ç«': 'æœ¨',
                'åœŸ': 'ç«'
            };
            if (!input || input.length < selfPosition) {
                return "Unable to analyze opinion - insufficient data.";
            }
            const selfElement = input[selfPosition - 1];
            const wealthElement = å°ç”Ÿå…³ç³»[selfElement];
            const wealthIndices = input.split('').reduce((indices, char, index) => {
                if (char === wealthElement) indices.push(index + 1);
                return indices;
            }, []);
            let result;
            if (wealthIndices.includes(selfPosition - 1) || wealthIndices.includes(selfPosition + 1)) {
                result = "You are very good at listening to others' perspectives.";
            } else if (wealthIndices.length === 0) {
                result = "You don't listen to others' perspectives at all.";
            } else if ([1, 3].some(i => wealthIndices.includes(i)) && !wealthIndices.includes(2)) {
                result = "You appear to like listening to others' opinions on the surface, but you don't really take them in.";
            } else if (!wealthIndices.includes(1) && wealthIndices.includes(2)) {
                result = "You seem not to like listening to others' opinions on the surface, but you actually take them in.";
            } else {
                result = "Sometimes you listen to others' opinions, and sometimes you don't.";
            }
            return result;
        }
        
        function analyzeSupport(input) {
            const selfPosition = 5;
            const å°ç”Ÿå…³ç³» = {
                'é‡‘': 'åœŸ',
                'æ°´': 'é‡‘',
                'æœ¨': 'æ°´',
                'ç«': 'æœ¨',
                'åœŸ': 'ç«'
            };
            if (!input || input.length < selfPosition) {
                return "Unable to analyze support - insufficient data.";
            }
            const selfElement = input[selfPosition - 1];
            const wealthElement = å°ç”Ÿå…³ç³»[selfElement];
            const wealthIndices = input.split('').reduce((indices, char, index) => {
                if (char === wealthElement) indices.push(index + 1);
                return indices;
            }, []);
            let result;
            if (wealthIndices.includes(selfPosition - 1) || wealthIndices.includes(selfPosition + 1)) {
                result = "Benefactors are very likely to extend their support to you.";
            } else if (wealthIndices.length === 0) {
                result = "It seems improbable that help will come your way.";
            } else {
                result = "Sometimes help comes your way, but other times it doesn't.";
            }
            return result;
        }
        
        function analyzeBoyPopular(input) {
            const selfPosition = 5;
            const å…‹åˆ¶å…³ç³» = {
                'é‡‘': 'æœ¨',
                'æ°´': 'ç«',
                'æœ¨': 'åœŸ',
                'ç«': 'é‡‘',
                'åœŸ': 'æ°´'
            };
            if (!input || input.length < selfPosition) {
                return "Unable to analyze popularity - insufficient data.";
            }
            const selfElement = input[selfPosition - 1];
            const wealthElement = å…‹åˆ¶å…³ç³»[selfElement];
            const wealthIndices = String(input).split('').reduce((indices, char, index) => {
                if (char === wealthElement) indices.push(index + 1);
                return indices;
            }, []);
            let result;
            if (wealthIndices.includes(selfPosition - 1) || wealthIndices.includes(selfPosition + 1)) {
                result = "You have a natural charm that draws the attention of the opposite sex.";
            } else if (wealthIndices.length === 0) {
                result = "You are not particularly sought after by the opposite sex.";
            } else {
                result = "Your charm is there, but it's not something that stands out significantly.";
            }
            return result;
        }
        
        function analyzeGirlPopular(input) {
            const selfPosition = 5;
            const å…‹åˆ¶å…³ç³» = {
                'é‡‘': 'ç«',
                'æ°´': 'åœŸ',
                'æœ¨': 'é‡‘',
                'ç«': 'æ°´',
                'åœŸ': 'æœ¨'
            };
            if (!input || input.length < selfPosition) {
                return "Unable to analyze popularity - insufficient data.";
            }
            const selfElement = input[selfPosition - 1];
            const wealthElement = å…‹åˆ¶å…³ç³»[selfElement];
            const wealthIndices = String(input).split('').reduce((indices, char, index) => {
                if (char === wealthElement) indices.push(index + 1);
                return indices;
            }, []);
            let result;
            if (wealthIndices.includes(selfPosition - 1) || wealthIndices.includes(selfPosition + 1)) {
                result = "You have a natural charm that draws the attention of the opposite sex.";
            } else if (wealthIndices.length === 0) {
                result = "You are not particularly sought after by the opposite sex.";
            } else {
                result = "Your charm is there, but it's not something that stands out significantly.";
            }
            return result;
        }
        
        function analyzeSexPopular(input, gender) {
            console.log("input:", input, "gender:", gender);
            if (gender === "Male") {
                return analyzeBoyPopular(input);
            } else {
                return analyzeGirlPopular(input);
            }
        }
        
        function analyzeIdealPartner(input, gender) {
            const tianGanWuXing = {
                'ç”²': 'æœ¨', 'ä¹™': 'æœ¨', 'ä¸™': 'ç«', 'ä¸': 'ç«', 'æˆŠ': 'åœŸ',
                'å·±': 'åœŸ', 'åºš': 'é‡‘', 'è¾›': 'é‡‘', 'å£¬': 'æ°´', 'ç™¸': 'æ°´'
            };
            const diZhiToTianGan = {
                'å­': ['ç™¸'], 'ä¸‘': ['å·±', 'ç™¸', 'è¾›'], 'å¯…': ['ç”²', 'ä¸™', 'æˆŠ'],
                'å¯': ['ä¹™'], 'è¾°': ['æˆŠ', 'ä¹™', 'ç™¸'], 'å·³': ['ä¸™', 'åºš', 'æˆŠ'],
                'åˆ': ['ä¸', 'å·±'], 'æœª': ['å·±', 'ä¹™', 'ä¸'], 'ç”³': ['åºš', 'å£¬', 'æˆŠ'],
                'é…‰': ['è¾›'], 'æˆŒ': ['æˆŠ', 'ä¸', 'è¾›'], 'äº¥': ['å£¬', 'ç”²']
            };
            const wuXingRelationship = {
                'æœ¨': { å…‹: 'åœŸ', ç”Ÿ: 'ç«', è¢«å…‹: 'é‡‘', è¢«ç”Ÿ: 'æ°´' },
                'ç«': { å…‹: 'é‡‘', ç”Ÿ: 'åœŸ', è¢«å…‹: 'æ°´', è¢«ç”Ÿ: 'æœ¨' },
                'åœŸ': { å…‹: 'æ°´', ç”Ÿ: 'é‡‘', è¢«å…‹: 'æœ¨', è¢«ç”Ÿ: 'ç«' },
                'é‡‘': { å…‹: 'æœ¨', ç”Ÿ: 'æ°´', è¢«å…‹: 'ç«', è¢«ç”Ÿ: 'åœŸ' },
                'æ°´': { å…‹: 'ç«', ç”Ÿ: 'æœ¨', è¢«å…‹: 'åœŸ', è¢«ç”Ÿ: 'é‡‘' }
            };
            const elements = String(input).split(',');
            if (elements.length < 7) {
                return 'Unable to analyze ideal partner - insufficient data.';
            }
            const targetTianGan = elements[5];
            const targetWuXing = tianGanWuXing[targetTianGan];
            const targetDiZhi = elements[6];
            const possibleTianGan = diZhiToTianGan[targetDiZhi];
            if (!targetWuXing || !possibleTianGan) {
                return 'Unable to analyze ideal partner - invalid input.';
            }
            const results = possibleTianGan.map(tianGan => {
                const wuXing = tianGanWuXing[tianGan];
                if (wuXing === wuXingRelationship[targetWuXing].å…‹) {
                    return "You hope your partner can bring you financial prosperity, and you can have control over your partner.";
                } else if (wuXing === wuXingRelationship[targetWuXing].è¢«å…‹) {
                    return "You hope your partner can appropriately regulate your behavior in life.";
                } else if (wuXing === wuXingRelationship[targetWuXing].ç”Ÿ) {
                    return "You hope you find someone you love as your spouse, someone you can confide in.";
                } else if (wuXing === wuXingRelationship[targetWuXing].è¢«ç”Ÿ) {
                    return "You hope to find someone who loves you as your spouse and is very supportive of you.";
                } else {
                    return "You hope to find someone like you, like a close brother, who can share joys and hardships with you.";
                }
            });
            return results.join('\n\n');
        }
        // --- END: DEALBAZI.JS ---
    
        // --- START: SCRIPT.JS (MODIFIED) ---
        const userInteraction = {
            birthday: null,
            currentCategory: null,
            bazi: null,
            riyuan: null,
            yuezhi: null,
            baziWuxing: null,
            gender: null,
        };
        
        // Categories and questions
        const categories = {
            Self: [
                { id: 'ioe', text: 'Am I an Introvert (I) or an Extrovert (E)?', handler: 'handleIOEQuestion' },
                { id: 'zodiac', text: 'What is my Chinese zodiac sign?', handler: 'handleZodiacQuestion' },
                { id: 'swipe', text: 'Please Swipe Left for More Questions', handler: 'handleSwipeQuestion' },
                { id: 'nature', text: 'If my personality were reflected in nature, would I be a tree, the sun, or a stream?', handler: 'handleNatureQuestion' },
                { id: 'confident', text: 'Am I a confident person?', handler: 'handleConfidentQuestion' },
                { id: 'calm', text: 'Am I someone who can handle situations calmly?', handler: 'handleCalmQuestion' },
                { id: 'adaptable', text: 'Am I adaptable when handling situations?', handler: 'handleAdaptableQuestion' },
                { id: 'courageous', text: 'Am I a courageous person?', handler: 'handleCourageousQuestion' },
                { id: 'compassionate', text: 'Am I a compassionate person?', handler: 'handleCompassionateQuestion' },
                { id: 'promises', text: 'Am I someone who values promises?', handler: 'handlePromisesQuestion' },
                { id: 'stranger', text: 'What impression do I leave on strangers?', handler: 'handleStrangerQuestion' },
                { id: 'familiar', text: 'How am I perceived by those who are familiar with me?', handler: 'handleFamiliarQuestion' },
                { id: 'myself', text: 'What is my true inner self?', handler: 'handleMyselfQuestion' }
            ],
            Love: [
                { id: 'ideal', text: "What are my expectations for an ideal partner?", handler: 'handleIdealPartnerQuestion' },
                { id: 'sexpopular', text: 'Am I someone who is popular with the opposite sex?', handler: 'handleSexPopularQuestion' }
            ],
            Wealth: [
                { id: 'wealth', text: 'Do I value wealth?', handler: 'handleWealthQuestion' },
                { id: 'purpose', text: 'Do I have a sense of purpose in what I do?', handler: 'handlePurposeQuestion' },
                { id: 'opinions', text: "Am I someone who is good at listening to others' opinions?", handler: 'handleOpinionsQuestion' },
                { id: 'support', text: "Do I have a higher chance of getting help from benefactors?", handler: 'handleSupportQuestion' }
            ],
        };
        
        // Load categories
        function loadCategories() {
            const optionsDiv = document.getElementById('options');
            if (!optionsDiv) {
                console.error("ERROR: options element not found.");
                return;
            }
            optionsDiv.innerHTML = '';
            
            Object.keys(categories).forEach((category) => {
                const button = document.createElement('button');
                button.textContent = category;
                button.onclick = () => loadQuestions(category);
                optionsDiv.appendChild(button);
            });
            
            const modifyButton = document.createElement('button');
            modifyButton.textContent = 'Modify Birthday & Gender';
            modifyButton.onclick = showInputGroup;
            optionsDiv.appendChild(modifyButton);
            
            const deepseekButton = document.createElement('button');
            deepseekButton.textContent = 'ğŸ’¬ Chat with DeepSeek';
            deepseekButton.onclick = toggleDeepSeekChat;
            optionsDiv.appendChild(deepseekButton);
        }
        
        // Toggle DeepSeek chat interface
        function toggleDeepSeekChat() {
            const deepseekGroup = document.getElementById('deepseek-chat-group');
            if (!deepseekGroup) return;
            
            if (deepseekGroup.style.display === 'none' || !deepseekGroup.style.display) {
                deepseekGroup.style.display = 'flex';
                // Focus on input
                const deepseekInput = document.getElementById('deepseek-input');
                if (deepseekInput) {
                    deepseekInput.focus();
                }
            } else {
                deepseekGroup.style.display = 'none';
            }
        }
        
        // Backend API endpoint - WordPress REST API
        // If index1.html is on the same domain as WordPress, use relative path:
        const DEEPSEEK_API_PROXY = '/wp-json/deepseek/v1/chat';
        
        // If index1.html is on a different domain, use full URL:
        // const DEEPSEEK_API_PROXY = 'https://yourwordpress.com/wp-json/deepseek/v1/chat';
        
        // TODO: Update this to match your WordPress installation
        
        // Load questions for a selected category
        function loadQuestions(category) {
            userInteraction.currentCategory = category;
            const optionsDiv = document.getElementById('options');
            if (!optionsDiv) return;
            optionsDiv.innerHTML = '';
            
            categories[category].forEach((question) => {
                const button = document.createElement('button');
                button.textContent = question.text;
                button.onclick = () => {
                    handleQuestion(question.handler);
                };
                optionsDiv.appendChild(button);
            });
            
            const backButton = document.createElement('button');
            backButton.textContent = 'Back to Categories';
            backButton.onclick = loadCategories;
            optionsDiv.appendChild(backButton);
        }
        
        function handleQuestion(handlerName) {
            if (typeof window[handlerName] === 'function') {
                window[handlerName]();
            } else {
                appendMessage('Error: Invalid handler specified.', 'bot');
            }
        }
        
        // Save user's birthday
        function saveUserBirthdayGender(bd, gender) {
            if (!bd) {
                console.warn("LOG: Cannot save - birthday is empty");
                return;
            }
            const birthday = bd + '.' + (gender || '');
            console.log("LOG: Saving birthday to storage:", birthday);
            if (window.parent !== window) {
                window.parent.postMessage({ action: 'saveBirthday', birthday }, '*');
            } else {
                localStorage.setItem('userBirthday', birthday);
                console.log("LOG: Birthday saved to localStorage:", localStorage.getItem('userBirthday'));
            }
        }
        
        // Update Bazi and Zodiac (simplified - requires full implementation)
        function updateBaziZodiac() {
            if (!userInteraction.birthday) return;
            try {
                if (typeof PaiPanFinal !== 'undefined' && typeof mypaipan !== 'undefined') {
                    const dateObject = new Date(userInteraction.birthday);
                    userInteraction.bazi = mypaipan.getBazi(dateObject, true);
                    // Additional processing would go here
                } else {
                    console.warn("PaiPanFinal not available");
                }
            } catch (e) {
                console.error("Error updating Bazi:", e);
            }
        }
        
        // Gender selection handler
        const genderModal = document.getElementById('genderModal');
        const maleButton = document.getElementById('maleButton');
        const femaleButton = document.getElementById('femaleButton');
        
        if (genderModal && maleButton && femaleButton) {
            document.getElementById('birthday-input').addEventListener('change', () => {
                genderModal.style.display = 'block';
            });
            
            maleButton.addEventListener('click', () => {
                genderModal.style.display = 'none';
                userInteraction.gender = 'Male';
                console.log("LOG: Gender set to Male, birthday:", userInteraction.birthday);
                // If birthday already exists, save the updated combination
                if (userInteraction.birthday) {
                    saveUserBirthdayGender(userInteraction.birthday, userInteraction.gender);
                    updateBaziZodiac();
                }
            });
            
            femaleButton.addEventListener('click', () => {
                genderModal.style.display = 'none';
                userInteraction.gender = 'Female';
                console.log("LOG: Gender set to Female, birthday:", userInteraction.birthday);
                // If birthday already exists, save the updated combination
                if (userInteraction.birthday) {
                    saveUserBirthdayGender(userInteraction.birthday, userInteraction.gender);
                    updateBaziZodiac();
                }
            });
        }
        
        // Send button event listener
        const sendButton = document.getElementById('send-button');
        const birthdayInput = document.getElementById('birthday-input');
        if (sendButton) {
            sendButton.addEventListener('click', sendMessage);
        }
        if (birthdayInput) {
            birthdayInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    sendMessage(e);
                }
            });
        }
        
        // DeepSeek API functions - Calls backend proxy instead of directly calling DeepSeek
        async function callDeepSeekAPI(userMessage) {
            // Show thinking indicator
            const chatBox = document.getElementById('chat-box');
            let thinkingMsg = null;
            if (chatBox) {
                thinkingMsg = document.createElement('div');
                thinkingMsg.className = 'message bot';
                thinkingMsg.textContent = 'ğŸ¤” Thinking...';
                thinkingMsg.id = 'deepseek-thinking-msg';
                chatBox.appendChild(thinkingMsg);
                chatBox.scrollTop = chatBox.scrollHeight;
            }
            
            try {
                // Call backend proxy (WordPress REST API or independent backend)
                const response = await fetch(DEEPSEEK_API_PROXY, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        message: userMessage
                    })
                });
                
                const data = await response.json();
                
                if (!response.ok) {
                    let errorMessage = data.error?.message || `HTTP error! status: ${response.status}`;
                    
                    // Handle specific error codes with user-friendly messages
                    if (response.status === 401) {
                        errorMessage = 'Invalid API Key. Server configuration error.';
                    } else if (response.status === 402) {
                        errorMessage = 'Insufficient Balance. The service account has insufficient credits. Please contact the administrator.';
                    } else if (response.status === 429) {
                        errorMessage = 'Rate limit exceeded. Please wait a moment and try again.';
                    } else if (response.status === 500) {
                        errorMessage = data.message || 'Server error. Please try again later.';
                    } else if (response.status === 503) {
                        errorMessage = 'Service unavailable. The backend server may be down. Please try again later.';
                    }
                    
                    throw new Error(errorMessage);
                }
                
                // Remove thinking message
                if (thinkingMsg && thinkingMsg.parentNode) {
                    thinkingMsg.parentNode.removeChild(thinkingMsg);
                }
                
                return data.content || 'No response from DeepSeek.';
            } catch (error) {
                console.error('DeepSeek API Error:', error);
                // Remove thinking message on error
                if (thinkingMsg && thinkingMsg.parentNode) {
                    thinkingMsg.parentNode.removeChild(thinkingMsg);
                }
                
                // Handle network errors
                if (error.message.includes('Failed to fetch') || error.message.includes('NetworkError')) {
                    appendMessage('âŒ Unable to connect to the server. Please check if the backend server is running.', 'bot');
                } else {
                    appendMessage(`âŒ ${error.message}`, 'bot');
                }
                return null;
            }
        }
        
        // Send message to DeepSeek
        async function sendDeepSeekMessage() {
            const deepseekInput = document.getElementById('deepseek-input');
            
            if (!deepseekInput) return;
            
            const userMessage = deepseekInput.value.trim();
            if (!userMessage) {
                appendMessage('Please enter a message.', 'bot');
                return;
            }
            
            // Display user message
            appendMessage(userMessage, 'user');
            deepseekInput.value = '';
            
            // Call DeepSeek API through backend proxy
            const response = await callDeepSeekAPI(userMessage);
            if (response) {
                displayResponseGradually(response);
            }
        }
        
        // DeepSeek event listeners
        const deepseekSendBtn = document.getElementById('deepseek-send-btn');
        const deepseekInput = document.getElementById('deepseek-input');
        
        if (deepseekSendBtn) {
            deepseekSendBtn.addEventListener('click', sendDeepSeekMessage);
        }
        
        if (deepseekInput) {
            deepseekInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    sendDeepSeekMessage();
                }
            });
        }
        
        // Load saved birthday from localStorage or parent window
        function loadSavedBirthday() {
            if (window.parent !== window) {
                // Iframe mode: try to get from parent (message listener already set up elsewhere)
                window.parent.postMessage({ action: 'fetchBirthday' }, '*');
                // Return false to show input, will be handled by message listener
                return false;
            } else {
                // Standalone mode: get from localStorage
                const savedBirthday = localStorage.getItem('userBirthday');
                if (savedBirthday) {
                    const [birthday, gender] = savedBirthday.split('.');
                    userInteraction.birthday = birthday;
                    userInteraction.gender = gender || null;
                    console.log("LOG: Loaded saved birthday from localStorage:", userInteraction.birthday, "gender:", userInteraction.gender);
                    updateBaziZodiac();
                    appendMessage(`Welcome back! Currently, the provided birthday and gender are: ${savedBirthday}`, 'bot');
                    loadCategories();
                    return true;
                }
            }
            return false;
        }
        
        // --- æœ€ç»ˆçš„ã€æœ€å®‰å…¨çš„å¯åŠ¨é€»è¾‘ï¼šç­‰å¾…æ•´ä¸ªé¡µé¢åŠ è½½å®Œæ¯• ---
        window.onload = function() {
            setTimeout(() => {
                console.log("LOG: STARTING APPLICATION INITIALIZATION...");
                // Try to load saved birthday first
                const hasSavedBirthday = loadSavedBirthday();
                if (!hasSavedBirthday) {
                    // No saved birthday, show welcome message and input
                    appendMessage('Welcome, Seeker. The stars have guided you here. What burden weighs on your heart today?(Type your birthday and gender below to begin):', 'bot');
                    showInputGroup();
                }
            }, 100);
        };
        
        // Question handler functions
        function handleSwipeQuestion(){
            const tooltip = document.getElementById('tooltip');
            if (tooltip) {
                tooltip.style.display = 'block';
                console.log("display indicate...");
                setTimeout(() => {
                    tooltip.style.display = 'none';
                }, 4000);
            }
        }
        
        function getBaziByIndex(bazi, number){
            const parts = String(bazi).split(',');
            if (parts.length >= 6) {
                return parts[number];
            }
            return null;
        }
        
        function getRiYuan(inputString) {
            const parts = String(inputString).split(',');
            if (parts.length >= 6) {
                return parts[5];
            }
            return null;
        }
        
        function getYueZhi(inputString) {
            const parts = String(inputString).split(',');
            if (parts.length >= 6) {
                return parts[4];
            }
            return null;
        }
        
        function adjustTime(inputDate) {
            const inputTime = new Date(inputDate);
            const currentDate = new Date(inputTime.getFullYear(), inputTime.getMonth(), inputTime.getDate());
            const cutoffTime = new Date(currentDate);
            cutoffTime.setHours(22, 59, 0, 0);
            
            if (inputTime > cutoffTime) {
                const nextDay = new Date(currentDate);
                nextDay.setDate(nextDay.getDate() + 1);
                nextDay.setHours(0, 30, 0, 0);
                return nextDay;
            }
            return inputTime;
        }
        
        function checkIOE() {
            const inputChar = userInteraction.riyuan;
            if (!inputChar) return 'Unknown';
            const tianGanE = ['ç”²', 'ä¸™', 'æˆŠ', 'åºš', 'å£¬'];
            return tianGanE.includes(inputChar) ? 'Extrovert (E)' : 'Introvert (I)';
        }
        
        function getZodiac() {
            const inputString = userInteraction.bazi;
            if (!inputString) return 'Unknown';
            const parts = String(inputString).split(',');
            if (parts.length >= 6) {
                return parts[0];
            }
            return null;
        }
        
        function handleIOEQuestion() {
            if (!ensureBaziDataAvailable()) {
                appendMessage('Please enter your birthday first.', 'bot');
                return;
            }
            const response = `You likely fall into the ${checkIOE()} category, if you were to take the MBTI test.`;
            displayResponseGradually(response);
        }
        
        function handleZodiacQuestion() {
            if (!ensureBaziDataAvailable()) {
                appendMessage('Please enter your birthday first.', 'bot');
                return;
            }
            const zodiac = getZodiac();
            const response = `Your Chinese zodiac sign is ${zodiac || 'Unknown'}.`;
            displayResponseGradually(response);
        }
        
        function handleNatureQuestion() {
            if (!ensureBaziDataAvailable()) {
                appendMessage('Please enter your birthday first.', 'bot');
                return;
            }
            if (typeof getRiYuanDescription === 'function') {
                const response = `If your personality were reflected in nature, you would be: ${getRiYuanDescription(userInteraction.riyuan)}.`;
                displayResponseGradually(response);
            } else {
                appendMessage('Analysis function not available. Please ensure all dependencies are loaded.', 'bot');
            }
        }
        
        function handleCalmQuestion() {
            if (!ensureBaziDataAvailable()) {
                appendMessage('Please enter your birthday first.', 'bot');
                return;
            }
            let result = '';
            if (typeof checkElementInString === 'function' && typeof checkCharacterAtPosition === 'function') {
                if (checkElementInString('é‡‘', userInteraction.baziWuxing) == false) {
                    result = 'You are NOT a calm person at all.';
                } else if (checkCharacterAtPosition('é‡‘', userInteraction.baziWuxing, 4) || checkCharacterAtPosition('é‡‘', userInteraction.baziWuxing, 5) || checkCharacterAtPosition('é‡‘', userInteraction.baziWuxing, 6)) {
                    result = 'You are a typical calm person.';
                } else {
                    result = 'You are somewhat a calm person, but not in a very typical sense.';
                }
            } else {
                result = 'Analysis function not available.';
            }
            displayResponseGradually(result);
        }
        
        function handleConfidentQuestion() {
            if (!ensureBaziDataAvailable()) {
                appendMessage('Please enter your birthday first.', 'bot');
                return;
            }
            if (typeof determineConfidence === 'function') {
                const response = `Actually you are ${determineConfidence(userInteraction.baziWuxing)} person.`;
                displayResponseGradually(response);
            } else {
                appendMessage('Analysis function not available.', 'bot');
            }
        }
        
        function handleAdaptableQuestion() {
            if (!ensureBaziDataAvailable()) {
                appendMessage('Please enter your birthday first.', 'bot');
                return;
            }
            let result = '';
            const ele = 'æ°´';
            const des = 'adaptable';
            if (typeof checkElementInString === 'function' && typeof checkCharacterAtPosition === 'function') {
                if (checkElementInString(ele, userInteraction.baziWuxing) == false) {
                    result = 'You are NOT an ' + des + ' person at all.';
                } else if (checkCharacterAtPosition(ele, userInteraction.baziWuxing, 4) || checkCharacterAtPosition(ele, userInteraction.baziWuxing, 5) || checkCharacterAtPosition(ele, userInteraction.baziWuxing, 6)) {
                    result = 'You are a typical ' + des + ' person.';
                } else {
                    result = 'You are somewhat an ' + des + ' person, but not in a very typical sense.';
                }
            } else {
                result = 'Analysis function not available.';
            }
            displayResponseGradually(result);
        }
        
        function handleCourageousQuestion() {
            if (!ensureBaziDataAvailable()) {
                appendMessage('Please enter your birthday first.', 'bot');
                return;
            }
            let result = '';
            const ele = 'æœ¨';
            const des = 'courageous';
            if (typeof checkElementInString === 'function' && typeof checkCharacterAtPosition === 'function') {
                if (checkElementInString(ele, userInteraction.baziWuxing) == false) {
                    result = 'You are NOT a ' + des + ' person at all.';
                } else if (checkCharacterAtPosition(ele, userInteraction.baziWuxing, 4) || checkCharacterAtPosition(ele, userInteraction.baziWuxing, 5) || checkCharacterAtPosition(ele, userInteraction.baziWuxing, 6)) {
                    result = 'You are a typical ' + des + ' person.';
                } else {
                    result = 'You are somewhat a ' + des + ' person, but not in a very typical sense.';
                }
            } else {
                result = 'Analysis function not available.';
            }
            displayResponseGradually(result);
        }
        
        function handleCompassionateQuestion() {
            if (!ensureBaziDataAvailable()) {
                appendMessage('Please enter your birthday first.', 'bot');
                return;
            }
            let result = '';
            const ele = 'ç«';
            const des = 'compassionate';
            if (typeof checkElementInString === 'function' && typeof checkCharacterAtPosition === 'function') {
                if (checkElementInString(ele, userInteraction.baziWuxing) == false) {
                    result = 'You are NOT a ' + des + ' person at all.';
                } else if (checkCharacterAtPosition(ele, userInteraction.baziWuxing, 4) || checkCharacterAtPosition(ele, userInteraction.baziWuxing, 5) || checkCharacterAtPosition(ele, userInteraction.baziWuxing, 6)) {
                    result = 'You are a typical ' + des + ' person.';
                } else {
                    result = 'You are somewhat a ' + des + ' person, but not in a very typical sense.';
                }
            } else {
                result = 'Analysis function not available.';
            }
            displayResponseGradually(result);
        }
        
        function handlePromisesQuestion() {
            if (!ensureBaziDataAvailable()) {
                appendMessage('Please enter your birthday first.', 'bot');
                return;
            }
            let result = '';
            const ele = 'åœŸ';
            const des = 'commitment-minded';
            if (typeof checkElementInString === 'function' && typeof checkCharacterAtPosition === 'function') {
                if (checkElementInString(ele, userInteraction.baziWuxing) == false) {
                    result = 'You are NOT a ' + des + ' person at all.';
                } else if (checkCharacterAtPosition(ele, userInteraction.baziWuxing, 4) || checkCharacterAtPosition(ele, userInteraction.baziWuxing, 5) || checkCharacterAtPosition(ele, userInteraction.baziWuxing, 6)) {
                    result = 'You are a typical ' + des + ' person.';
                } else {
                    result = 'You are somewhat a ' + des + ' person, but not in a very typical sense.';
                }
            } else {
                result = 'Analysis function not available.';
            }
            displayResponseGradually(result);
        }
        
        function handleMyselfQuestion() {
            if (!ensureBaziDataAvailable()) {
                appendMessage('Please enter your birthday first.', 'bot');
                return;
            }
            if (typeof getDiZhiPersonality === 'function') {
                let result = getDiZhiPersonality(getBaziByIndex(userInteraction.bazi, 4));
                if (getBaziByIndex(userInteraction.bazi, 4) !== getBaziByIndex(userInteraction.bazi, 6)) {
                    result += '\n\n ' + getDiZhiPersonality(getBaziByIndex(userInteraction.bazi, 6));
                }
                if (getBaziByIndex(userInteraction.bazi, 2) !== getBaziByIndex(userInteraction.bazi, 4) && getBaziByIndex(userInteraction.bazi, 2) !== getBaziByIndex(userInteraction.bazi, 6)) {
                    result += '\n\n ' + getDiZhiPersonality(getBaziByIndex(userInteraction.bazi, 2));
                }
                const response = `This is what your true inner personality is like: \n\n ${result}`;
                displayResponseGradually(response);
            } else {
                appendMessage('Analysis function not available.', 'bot');
            }
        }
        
        function handleStrangerQuestion() {
            if (!ensureBaziDataAvailable()) {
                appendMessage('Please enter your birthday first.', 'bot');
                return;
            }
            if (typeof getTianGanTraits === 'function') {
                let result = getTianGanTraits(getBaziByIndex(userInteraction.bazi, 1));
                if (getBaziByIndex(userInteraction.bazi, 1) !== getBaziByIndex(userInteraction.bazi, 3)) {
                    result += '\n\n ' + getTianGanTraits(getBaziByIndex(userInteraction.bazi, 3));
                }
                const response = `This is the impression you leave on people when they first meet you: \n\n ${result}`;
                displayResponseGradually(response);
            } else {
                appendMessage('Analysis function not available.', 'bot');
            }
        }
        
        function handleFamiliarQuestion() {
            if (!ensureBaziDataAvailable()) {
                appendMessage('Please enter your birthday first.', 'bot');
                return;
            }
            if (typeof getTianGanTraits === 'function') {
                const response = `Here's the impression you leave on people who are familiar with you: \n\n ${getTianGanTraits(getBaziByIndex(userInteraction.bazi, 5))}\n\n`;
                displayResponseGradually(response);
            } else {
                appendMessage('Analysis function not available.', 'bot');
            }
        }
        
        // Helper function to ensure Bazi data is available
        function ensureBaziDataAvailable() {
            // First check if birthday exists
            if (!userInteraction.birthday) {
                // Try to load from localStorage
                const savedBirthday = localStorage.getItem('userBirthday');
                if (savedBirthday) {
                    const [birthday, gender] = savedBirthday.split('.');
                    userInteraction.birthday = birthday;
                    if (gender) {
                        userInteraction.gender = gender;
                    }
                    console.log("LOG: Loaded birthday from localStorage:", userInteraction.birthday);
                } else {
                    console.log("LOG: No birthday found in localStorage");
                    return false;
                }
            }
            
            // If birthday exists but bazi data is missing, recalculate
            if (userInteraction.birthday && (!userInteraction.bazi || !userInteraction.baziWuxing)) {
                console.log("LOG: Birthday exists but Bazi data missing, recalculating...");
                updateBaziZodiac();
                // Wait a bit for calculation to complete, then check again
                // If still missing after calculation, at least we have birthday
            }
            
            // Return true if birthday exists (even if bazi calculation failed)
            // This allows the app to continue working with birthday
            if (userInteraction.birthday) {
                console.log("LOG: Birthday available:", userInteraction.birthday, "Bazi:", userInteraction.bazi ? "exists" : "missing", "BaziWuxing:", userInteraction.baziWuxing ? "exists" : "missing");
                return true;
            }
            
            return false;
        }
        
        function handleSexPopularQuestion() {
            if (!ensureBaziDataAvailable() || !userInteraction.gender) {
                appendMessage('Please enter your birthday and gender first.', 'bot');
                return;
            }
            if (typeof analyzeSexPopular === 'function') {
                if (!userInteraction.baziWuxing) {
                    appendMessage('Bazi data is not available. Please re-enter your birthday.', 'bot');
                    return;
                }
                const result = analyzeSexPopular(userInteraction.baziWuxing, userInteraction.gender);
                if (result) {
                    displayResponseGradually(result);
                } else {
                    appendMessage('Unable to analyze popularity. Please try again.', 'bot');
                }
            } else {
                appendMessage('Analysis function not available.', 'bot');
            }
        }
        
        function handleIdealPartnerQuestion() {
            if (!ensureBaziDataAvailable() || !userInteraction.gender) {
                appendMessage('Please enter your birthday and gender first.', 'bot');
                return;
            }
            if (typeof analyzeIdealPartner === 'function') {
                if (!userInteraction.bazi) {
                    appendMessage('Bazi data is not available. Please re-enter your birthday.', 'bot');
                    return;
                }
                const result = analyzeIdealPartner(userInteraction.bazi, userInteraction.gender);
                if (result) {
                    displayResponseGradually(result);
                } else {
                    appendMessage('Unable to analyze ideal partner. Please try again.', 'bot');
                }
            } else {
                appendMessage('Analysis function not available.', 'bot');
            }
        }
        
        function handleSupportQuestion() {
            if (!ensureBaziDataAvailable()) {
                appendMessage('Please enter your birthday first.', 'bot');
                return;
            }
            if (typeof analyzeSupport === 'function') {
                if (!userInteraction.baziWuxing) {
                    appendMessage('Bazi data is not available. Please re-enter your birthday.', 'bot');
                    return;
                }
                const result = analyzeSupport(userInteraction.baziWuxing);
                if (result) {
                    displayResponseGradually(result);
                } else {
                    appendMessage('Unable to analyze support. Please try again.', 'bot');
                }
            } else {
                appendMessage('Analysis function not available.', 'bot');
            }
        }
        
        function handleOpinionsQuestion() {
            if (!ensureBaziDataAvailable()) {
                appendMessage('Please enter your birthday first.', 'bot');
                return;
            }
            if (typeof analyzeOpinion === 'function') {
                if (!userInteraction.baziWuxing) {
                    appendMessage('Bazi data is not available. Please re-enter your birthday.', 'bot');
                    return;
                }
                const result = analyzeOpinion(userInteraction.baziWuxing);
                if (result) {
                    displayResponseGradually(result);
                } else {
                    appendMessage('Unable to analyze opinions. Please try again.', 'bot');
                }
            } else {
                appendMessage('Analysis function not available.', 'bot');
            }
        }
        
        function handlePurposeQuestion() {
            if (!ensureBaziDataAvailable()) {
                appendMessage('Please enter your birthday first.', 'bot');
                return;
            }
            if (typeof analyzePurpose === 'function') {
                if (!userInteraction.baziWuxing) {
                    appendMessage('Bazi data is not available. Please re-enter your birthday.', 'bot');
                    return;
                }
                const result = analyzePurpose(userInteraction.baziWuxing);
                if (result) {
                    displayResponseGradually(result);
                } else {
                    appendMessage('Unable to analyze purpose. Please try again.', 'bot');
                }
            } else {
                appendMessage('Analysis function not available.', 'bot');
            }
        }
        
        function handleWealthQuestion() {
            if (!ensureBaziDataAvailable()) {
                appendMessage('Please enter your birthday first.', 'bot');
                return;
            }
            if (typeof analyzeWealth === 'function') {
                if (!userInteraction.baziWuxing) {
                    appendMessage('Bazi data is not available. Please re-enter your birthday.', 'bot');
                    return;
                }
                const result = analyzeWealth(userInteraction.baziWuxing);
                if (result) {
                    displayResponseGradually(result);
                } else {
                    appendMessage('Unable to analyze wealth. Please try again.', 'bot');
                }
            } else {
                appendMessage('Analysis function not available.', 'bot');
            }
        }
        
        // Update updateBaziZodiac to use helper functions
        function updateBaziZodiac() {
            if (!userInteraction.birthday) {
                console.warn("LOG: Cannot update Bazi - birthday not set");
                return;
            }
            try {
                console.log("LOG: Updating Bazi with birthday:", userInteraction.birthday);
                if (typeof PaiPanFinal !== 'undefined') {
                    const mypaipan = new PaiPanFinal();
                    const dateObject1 = new Date(userInteraction.birthday);
                    const dateObject = adjustTime(dateObject1);
                    const baziArray = mypaipan.getBazi(dateObject, true);
                    // Convert array to comma-separated string format expected by other functions
                    // Format: zodiac,å¹´å¹²,å¹´æ”¯,æœˆå¹²,æœˆæ”¯,æ—¥å¹²,æ—¥æ”¯,æ—¶å¹²,æ—¶æ”¯
                    userInteraction.bazi = baziArray.join(',');
                    userInteraction.riyuan = getRiYuan(userInteraction.bazi);
                    userInteraction.yuezhi = getYueZhi(userInteraction.bazi);
                    
                    // Transform to Wuxing
                    if (typeof transformGanZhiToWuXing === 'function') {
                        userInteraction.baziWuxing = transformGanZhiToWuXing(userInteraction.bazi);
                        console.log("LOG: BaziWuxing calculated:", userInteraction.baziWuxing);
                    } else {
                        console.error("LOG: transformGanZhiToWuXing function not available");
                    }
                    console.log("LOG: Bazi updated successfully. æ­¤äººä¿¡æ¯ã€" + userInteraction.bazi + (userInteraction.baziWuxing || '') + "ã€‘");
                } else {
                    console.warn("PaiPanFinal not available");
                }
            } catch (e) {
                console.error("Error updating Bazi:", e);
            }
        }
        
        // Helper function to ensure birthday is available
        function ensureBirthdayAvailable() {
            if (!userInteraction.birthday) {
                // Try to load from localStorage
                const savedBirthday = localStorage.getItem('userBirthday');
                if (savedBirthday) {
                    const [birthday, gender] = savedBirthday.split('.');
                    userInteraction.birthday = birthday;
                    if (gender) {
                        userInteraction.gender = gender;
                    }
                    updateBaziZodiac();
                    return true;
                }
                return false;
            }
            return true;
        }
        
        // Expose handler functions to global scope so they can be called by handleQuestion
        window.handleIOEQuestion = handleIOEQuestion;
        window.handleZodiacQuestion = handleZodiacQuestion;
        window.handleNatureQuestion = handleNatureQuestion;
        window.handleCalmQuestion = handleCalmQuestion;
        window.handleConfidentQuestion = handleConfidentQuestion;
        window.handleAdaptableQuestion = handleAdaptableQuestion;
        window.handleCourageousQuestion = handleCourageousQuestion;
        window.handleCompassionateQuestion = handleCompassionateQuestion;
        window.handlePromisesQuestion = handlePromisesQuestion;
        window.handleMyselfQuestion = handleMyselfQuestion;
        window.handleStrangerQuestion = handleStrangerQuestion;
        window.handleFamiliarQuestion = handleFamiliarQuestion;
        window.handleSexPopularQuestion = handleSexPopularQuestion;
        window.handleIdealPartnerQuestion = handleIdealPartnerQuestion;
        window.handleSupportQuestion = handleSupportQuestion;
        window.handleOpinionsQuestion = handleOpinionsQuestion;
        window.handlePurposeQuestion = handlePurposeQuestion;
        window.handleWealthQuestion = handleWealthQuestion;
        window.handleSwipeQuestion = handleSwipeQuestion;
        
        // --- END: SCRIPT.JS ---
        })(); 
    // é—­åˆ IIFE
    </script>
</body>
</html>