<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FateFinder AI Chat Debug</title>
    
    <style>
        /* 请在 CSS 块的顶部添加这个全局规则，以确保所有元素都遵循现代模型 */
    *,
    *::before,
    *::after {
        box-sizing: border-box;
    }
    
    /* 或者，您只针对弹窗内容添加 */
    .modal-content {
        /* 保持原有的样式... */
        box-sizing: border-box; /* 强制将 padding 和 border 包含在 width 内 */
    }
        
        /* 容器和布局样式 */
        #ai-chat-container-wrapper {
            width: 100%; 
            max-width: 700px;
            margin: 0 auto;
            padding: 20px 0;
            color: #e0e0e0;
            font-family: Arial, sans-serif;
        }
    
        #chat-container {
            background: rgba(30, 30, 30, 0.95) !important;
            border-radius: 10px !important;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5) !important;
            width: 100% !important;
            padding: 20px !important;
            display: flex !important;
            flex-direction: column !important;
            position: relative !important;
            z-index: 1 !important;
            border: 1px solid #404040 !important;
            pointer-events: auto !important;
            height: 800px !important;
            max-height: 800px !important;
            overflow: hidden !important;
        }
    
        #chat-box {
            flex: 1 1 auto; 
            min-height: 0;
            padding: 10px;
            overflow-y: auto !important;
            overflow-x: hidden !important;
            border: 1px solid #404040;
            border-radius: 5px;
            margin-bottom: 20px;
            background: #1a1a1a;
            color: #e0e0e0;
        }
    
        /* 滚动条样式 */
        #chat-box::-webkit-scrollbar, #options::-webkit-scrollbar { width: 8px; }
        #chat-box::-webkit-scrollbar-track, #options::-webkit-scrollbar-track { background: #1a1a1a; }
        #chat-box::-webkit-scrollbar-thumb, #options::-webkit-scrollbar-thumb { background: #404040; border-radius: 4px; }
        #chat-box::-webkit-scrollbar-thumb:hover, #options::-webkit-scrollbar-thumb:hover { background: #555555; }
        
        /* 输入组和按钮样式 */
        #input-group { display: none; flex-direction: column; gap: 10px; margin-bottom: 20px; padding: 10px; border-top: 1px solid #404040; background-color: #1a1a1a; align-items: center; flex-shrink: 0; }
        #birthday-input { flex: 1; height: 20px; padding: 10px; border: 1px solid #404040; border-radius: 4px; margin-left: 50px; margin-right: 10px; background-color: #2d2d2d; color: #e0e0e0; }
        #birthday-input:focus { outline: none; border-color: #5a9; }
        #send-button { height: 40px; margin-left: 10px; padding: 10px 20px; border: none; background-color: #5a9; color: #ffffff; border-radius: 4px; cursor: pointer; margin-right: 50px; }
        #send-button:hover { background-color: #6bb; }
    
        /* 选项样式 */
        #options { display: flex; flex-direction: column; flex-wrap: wrap; justify-content: center; gap: 10px; max-height: 200px; overflow-y: auto; scroll-behavior: smooth; padding: 10px; border: 1px solid #404040; background: #1a1a1a; flex-shrink: 0; }
        #options button { margin: 5px; padding: 10px 20px; border: none; border-radius: 4px; cursor: pointer; background-color: #2d4a5a; color: #e0e0e0; }
        #options button:hover { background-color: #3d5a6a; }
    
        /* 消息样式 */
        .message { display: flex; align-items: center; margin: 5px 0; padding: 10px; border-radius: 5px; max-width: 80%; color: #e0e0e0; clear: both; }
        .message.bot { background-color: rgba(90, 153, 153, 0.3); align-self: flex-start; border: 1px solid rgba(90, 153, 153, 0.5); }
        .message.user { background-color: #2d4a5a; align-self: flex-end; color: #e0e0e0; border: 1px solid #3d5a6a; }
        
        /* 模态框和工具提示 */
        .modal { display: none; position: fixed; z-index: 9999; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.7); }
        .modal-content { background-color: #2d2d2d; margin: 15% auto; padding: 20px; border: 1px solid #404040; width: 300px; text-align: center; color: #e0e0e0; border-radius: 8px; }
        .modal-content p { color: #e0e0e0; }
        .tooltip { display: none; position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%); background: rgba(45, 74, 90, 0.9); color: #e0e0e0; padding: 10px; border-radius: 5px; font-size: 14px; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3); border: 1px solid #5a9; }
    
        /* 其他样式 (Thinking, Media Queries) */
        .thinking { display: flex; align-items: center; justify-content: center; margin: 10px 0; }
        .thinking span { width: 8px; height: 8px; margin: 0 2px; background-color: #5a9; border-radius: 50%; display: inline-block; animation: bounce 1.1s infinite both; }
        .thinking span:nth-child(1) { animation-delay: -0.32s; }
        .thinking span:nth-child(2) { animation-delay: -0.16s; }
        @keyframes bounce { 0%, 80%, 100% { transform: scale(0); } 40% { transform: scale(1); } }
        /* 响应式设计 */
        @media only screen and (orientation: portrait) { #chat-container { width: 90%; height: 90%; } #chat-box { padding: 10px; max-height: calc(100vh - 150px); } #input-group { padding: 5px; } #options button { padding: 8px 16px; } }
        @media only screen and (orientation: landscape) { #chat-container { width: 60%; height: 80%; } #chat-box { padding: 10px; max-height: calc(100vh - 150px); } #input-group { padding: 5px; } #options button { padding: 8px 16px; } }
    </style>
    
</head>
<body>
    <div id="ai-chat-container-wrapper">
        <div id="chat-container">
            <div id="chat-box"></div>
            <div id="input-group">
                <input type="datetime-local" id="birthday-input" placeholder="Enter your date and time of birth">
                <button id="send-button">Submit</button>
            </div>
            <div id="tooltip" class="tooltip">Swipe Left for More...</div>
            <div id="options"></div>
            <div id="deepseek-chat-group" style="display: none; flex-direction: column; gap: 10px; margin-top: 10px; padding: 10px; border-top: 1px solid #404040; background-color: #1a1a1a; flex-shrink: 0;">
                <div style="display: flex; gap: 10px; align-items: center;">
                    <input type="text" id="deepseek-input" placeholder="Ask DeepSeek anything..." style="flex: 1; padding: 8px; border: 1px solid #404040; border-radius: 4px; background-color: #2d2d2d; color: #e0e0e0;">
                    <button id="deepseek-send-btn" style="padding: 8px 15px; border: none; background-color: #5a9; color: #ffffff; border-radius: 4px; cursor: pointer;">Send</button>
                </div>
            </div>
            <div id="genderModal" class="modal">
                <div class="modal-content">
                    <p>To provide a more accurate answer to your query, please enter the gender you were assigned at birth:</p>
                    <button id="maleButton">Male</button>
                    <button id="femaleButton">Female</button>
                </div>
            </div>
        </div>
        </div>

    <script>
        (
    function() 
    {
        // --- START: HOISTED CORE UI FUNCTIONS (THE FIX) ---
        function appendMessage(text, sender) { 
            console.log("LOG: Function appendMessage called. Sender:", sender);
            const chatBox = document.getElementById('chat-box');
            
            if (!chatBox) {
                console.error("CRITICAL ERROR: chatBox element not found in appendMessage. Cannot append message.");
                return;
            }
    
            const messageElement = document.createElement('div');
            messageElement.className = `message ${sender}`;
            messageElement.textContent = text;
            chatBox.appendChild(messageElement);
            console.log("LOG: Message element appended to chatBox.");
    
            chatBox.scrollTop = chatBox.scrollHeight;
        }
        function displayResponseGradually(responseOrigin) { 
            console.log("LOG: Function displayResponseGradually called with:", responseOrigin);
            if (!responseOrigin) {
                console.error("LOG: displayResponseGradually received undefined or null response");
                appendMessage('Error: Unable to generate response. Please try again.', 'bot');
                return;
            }
            const response = String(responseOrigin).replace(/\n/g, '<br>');
            const chatBox = document.getElementById('chat-box');
            const message = document.createElement('div');
            message.classList.add('message', 'bot');
            chatBox.appendChild(message);
    
            let index = 0;
            const interval = setInterval(() => {
                message.innerHTML = `<p>${response.slice(0, index)}</p>`;
                chatBox.scrollTop = chatBox.scrollHeight;
                index++;
                if (index > response.length) clearInterval(interval);
            }, 50);
        }
        function showInputGroup() {
            console.log("LOG: Function showInputGroup called.");
            const inputGroup = document.getElementById('input-group');
            if (!inputGroup) {
                 console.error("CRITICAL ERROR: inputGroup element not found in showInputGroup.");
                 return;
            }
            
            inputGroup.style.display = 'flex';
            
            const birthdayInput = document.getElementById('birthday-input');
            if(birthdayInput) {
                 birthdayInput.focus();
            } else {
                 console.error("ERROR: birthdayInput element not found.");
            }
        }
        function sendMessage(event) {
            console.log("LOG: Function sendMessage called.");
            const birthdayInput = document.getElementById('birthday-input');
            const birthdayMessage = birthdayInput.value.trim();
            if (!birthdayMessage) {
                appendMessage('Please enter a valid date and time of birth.', 'bot');
                return;
            }
    
            // Save birthday globally
            userInteraction.birthday = birthdayMessage;
            console.log("LOG: Birthday saved to userInteraction:", userInteraction.birthday);
            
            // Save to localStorage for persistence (even if gender is not set yet)
            saveUserBirthdayGender(birthdayMessage, userInteraction.gender);
            
            // Update Bazi calculation with the new birthday
            updateBaziZodiac();
            
            birthdayInput.value = '';
            document.getElementById('input-group').style.display = 'none';
            appendMessage(`Your birthday has been saved: ${birthdayMessage}`, 'user');
            loadCategories();
        }
        // --- END: HOISTED CORE UI FUNCTIONS ---
        
        // --- START: LUNA.JS ---
        class Lunar { 
            constructor(date) {
                if (!date) {
                    date = new Date();
                }
                this.init(date.getTime());
            }
            // ... (Full Lunar class content continues) ...
            static lunarInfo = [
                0x4bd8, 0x4ae0, 0xa570, 0x54d5, 0xd260, 0xd950, 0x5554, 0x56af,
                0x9ad0, 0x55d2, 0x4ae0, 0xa5b6, 0xa4d0, 0xd250, 0xd295, 0xb54f,
                0xd6a0, 0xada2, 0x95b0, 0x4977, 0x497f, 0xa4b0, 0xb4b5, 0x6a50,
                0x6d40, 0xab54, 0x2b6f, 0x9570, 0x52f2, 0x4970, 0x6566, 0xd4a0,
                0xea50, 0x6a95, 0x5adf, 0x2b60, 0x86e3, 0x92ef, 0xc8d7, 0xc95f,
                0xd4a0, 0xd8a6, 0xb55f, 0x56a0, 0xa5b4, 0x25df, 0x92d0, 0xd2b2,
                0xa950, 0xb557, 0x6ca0, 0xb550, 0x5355, 0x4daf, 0xa5b0, 0x4573,
                0x52bf, 0xa9a8, 0xe950, 0x6aa0, 0xaea6, 0xab50, 0x04b60, 0xaae4,
                0xa570, 0x5260, 0xf263, 0xd950, 0x5b57, 0x56a0, 0x96d0, 0x4dd5,
                0x4ad0, 0xa4d0, 0xd4d4, 0xd250, 0xd558, 0xb540, 0xb6a0, 0x95a6,
                0x95bf, 0x49b0, 0xa974, 0xa4b0, 0xb27a, 0x6a50, 0x6d40, 0xaf46,
                0xab60, 0x9570, 0x4af5, 0x4970, 0x64b0, 0x74a3, 0xea50, 0x6b58,
                0x5ac0, 0xab60, 0x96d5, 0x92e0, 0xc960, 0xd954, 0xd4a0, 0xda50,
                0x7552, 0x56a0, 0xabb7, 0x025d0, 0x92d0, 0xcab5, 0xa950, 0xb4a0,
                0xbaa4, 0xad50, 0x55d9, 0x4ba0, 0xa5b0, 0x5176, 0x52bf, 0xa930,
                0x7954, 0x6aa0, 0xad50, 0x5b52, 0x4b60, 0xa6e6, 0xa4e0, 0xd260,
                0xea65, 0xd530, 0x5aa0, 0x76a3, 0x96d0, 0x4afb, 0x4ad0, 0xa4d0,
                0xd0b6, 0xd25f, 0xd520, 0xdd45, 0xb5a0, 0x56d0, 0x55b2, 0x49b0,
                0xa577, 0xa4b0, 0xaa50, 0xb255, 0x6d2f, 0xada0, 0x4b63, 0x937f,
                0x49f8, 0x4970, 0x64b0, 0x68a6, 0xea5f, 0x6b20, 0xa6c4, 0xaaef,
                0x92e0, 0xd2e3, 0xc960, 0xd557, 0xd4a0, 0xda50, 0x5d55, 0x56a0,
                0xa6d0, 0x55d4, 0x52d0, 0xa9b8, 0xa950, 0xb4a0, 0xb6a6, 0xad50,
                0x55a0, 0xaba4, 0xa5b0, 0x52b0, 0xb273, 0x6930, 0x7337, 0x6aa0,
                0xad50, 0x4b55, 0x4b6f, 0xa570, 0x54e4, 0xd260, 0xe968, 0xd520,
                0xdaa0, 0x6aa6, 0x56df, 0x4ae0, 0xa9d4, 0xa4d0, 0xd150, 0xf252, 0xd520
            ];
            
            static solarTermInfo = [
                0, 21208, 42467, 63836, 85337, 107014, 128867, 150921,
                173149, 195551, 218072, 240693, 263343, 285989, 308563, 331033,
                353350, 375494, 397447, 419210, 440795, 462224, 483532, 504758
            ];
            
            // 获取节气的完整时间（Date对象）
            static getSolarTermTime(solarYear, index) {
                const baseDate = new Date(1900, 0, 6, 2, 5, 0);
                const time = baseDate.getTime() + 31556925974.7 * (solarYear - 1900) + Lunar.solarTermInfo[index] * 60000;
                return new Date(time);
            }
            
            // 获取节气的日期（仅用于兼容）
            static getSolarTermDay(solarYear, index) {
                return Lunar.getSolarTermTime(solarYear, index).getDate();
            }
            static Tianan = ["甲", "乙", "丙", "丁", "戊", "己", "庚", "辛", "壬", "癸"];
            static Deqi = ["子", "丑", "寅", "卯", "辰", "巳", "午", "未", "申", "酉", "戌", "亥"];
            static Animals = ["鼠", "牛", "虎", "兔", "龙", "蛇", "马", "羊", "猴", "鸡", "狗", "猪"];
            static solarTerm = ["小寒", "大寒", "立春", "雨水", "惊蛰", "春分", "清明", "谷雨", "立夏", "小满", "芒种", "夏至", "小暑", "大暑", "立秋", "处暑", "白露", "秋分", "寒露", "霜降", "立冬", "小雪", "大雪", "冬至"];
            static lunarString1 = ["零", "一", "二", "三", "四", "五", "六", "七", "八", "九"];
            static lunarString2 = ["初", "十", "廿", "卅", "正", "腊", "冬", "闰"];
    
            static getLunarLeapMonth(lunarYear) { /* ... */ return (lunarYear - 1900) & 0xf; }
            // ... (Remaining methods of Lunar class) ...
            init(TimeInMillis) { /* ... */ }
            getCyclicalData() { /* ... */ }
            getAnimalString() { /* ... */ }
            getTermString() { /* ... */ }
            getCyclicalDateString() { /* ... */ }
            getCyclicaYear() { /* ... */ }
            getCyclicaMonth() { /* ... */ }
            getCyclicaDay() { /* ... */ }
            getLunarDayString() { /* ... */ }
            getLunarMonthString() { /* ... */ }
            getLunarYearString() { /* ... */ }
            getLunarDateString() { /* ... */ }
        }
        // --- END: LUNA.JS ---
    
        // --- START: BAZI.JS ---
        const chineseNumber = ["正", "二", "三", "四", "五", "六", "七", "八", "九", "十", "十一", "腊"];
        const Gan = ["甲", "乙", "丙", "丁", "戊", "己", "庚", "辛", "壬", "癸"];
        const Zhi = ["子", "丑", "寅", "卯", "辰", "巳", "午", "未", "申", "酉", "戌", "亥"];
        const lunarInfo = [
            0x04bd8, 0x04ae0, 0x0a570, 0x054d5, 0x0d260, 0x0d950, 0x16554, 0x056a0, 0x09ad0, 0x055d2,
            0x04ae0, 0x0a5b6, 0x0a4d0, 0x0d250, 0x1d255, 0x0b540, 0x0d6a0, 0x0ada2, 0x095b0, 0x14977,
            0x04970, 0x0a4b0, 0x0b4b5, 0x06a50, 0x06d40, 0x1ab54, 0x02b60, 0x09570, 0x052f2, 0x04970,
            0x06566, 0x0d4a0, 0x0ea50, 0x06e95, 0x05ad0, 0x02b60, 0x186e3, 0x092e0, 0x1c8d7, 0x0c950,
            0x0d4a0, 0x1d8a6, 0x0b550, 0x056a0, 0x1a5b4, 0x025d0, 0x092d0, 0x0d2b2, 0x0a950, 0x0b557,
            0x06ca0, 0x0b550, 0x15355, 0x04da0, 0x0a5d0, 0x14573, 0x052d0, 0x0a9a8, 0x0e950, 0x06aa0,
            0x0aea6, 0x0ab50, 0x04b60, 0x0aae4, 0x0a570, 0x05260, 0x0f263, 0x0d950, 0x05b57, 0x056a0,
            0x096d0, 0x04dd5, 0x04ad0, 0x0a4d0, 0x0d4d4, 0x0d250, 0x0d558, 0x0b540, 0x0b5a0, 0x195a6,
            0x095b0, 0x049b0, 0x0a974, 0x0a4b0, 0x0b27a, 0x06a50, 0x06d40, 0x0af46, 0x0ab60, 0x09570,
            0x04af5, 0x04970, 0x064b0, 0x074a3, 0x0ea50, 0x06b58, 0x055c0, 0x0ab60, 0x096d5, 0x092e0,
            0x0c960, 0x0d954, 0x0d4a0, 0x0da50, 0x07552, 0x056a0, 0x0abb7, 0x025d0, 0x092d0, 0x0cab5,
            0x0a950, 0x0b4a0, 0x0baa4, 0x0ad50, 0x055d9, 0x04ba0, 0x0a5b0, 0x15176, 0x052b0, 0x0a930,
            0x07954, 0x06aa0, 0x0ad50, 0x05b52, 0x04b60, 0x0a6e6, 0x0a4e0, 0x0d260, 0x0ea65, 0x0d530,
            0x05aa0, 0x076a3, 0x096d0, 0x04bd7, 0x04ad0, 0x0a4d0, 0x1d0b6, 0x0d250, 0x0d520, 0x0dd45,
            0x0b5a0, 0x056d0, 0x055b2, 0x049b0, 0x0a577, 0x0a4b0, 0x0aa50, 0x1b255, 0x06d20, 0x0ada0
        ];
        const chineseDateFormat = new Intl.DateTimeFormat('zh-CN', { year: 'numeric', month: '2-digit', day: '2-digit' });
        
        class BaZi {
            constructor(cal) {
                this.cal = cal;
                this.baseDate = new Date(1900, 0, 31);
                this.init();
            }

            init() {
                console.log("=== DEBUG: BaZi.init 开始计算农历 ===");
                console.log("DEBUG: 输入公历日期:", this.cal.toLocaleString('zh-CN'));
                
                let offset = Math.floor((this.cal - this.baseDate) / 86400000);
                console.log("DEBUG: 距离基准日期的天数偏移:", offset);
                let dayCyl = offset + 40;
                let monCyl = 14;

                let iYear, daysOfYear = 0;
                for (iYear = 1900; iYear < 2050 && offset > 0; iYear++) {
                    daysOfYear = this.yearDays(iYear);
                    offset -= daysOfYear;
                    monCyl += 12;
                }
                if (offset < 0) {
                    offset += daysOfYear;
                    iYear--;
                    monCyl -= 12;
                }

                this.year = iYear;
                console.log("DEBUG: 计算出的农历年份:", this.year);
                let yearCyl = iYear - 1864;
                let leapMonth = this.leapMonth(iYear);
                console.log("DEBUG: 该年是否有闰月:", leapMonth > 0 ? "是，闰" + leapMonth + "月" : "否");
                this.leap = false;

                let iMonth, daysOfMonth = 0;
                for (iMonth = 1; iMonth < 13 && offset > 0; iMonth++) {
                    if (leapMonth > 0 && iMonth == (leapMonth + 1) && !this.leap) {
                        --iMonth;
                        this.leap = true;
                        daysOfMonth = this.leapDays(this.year);
                        console.log("DEBUG: 遇到闰月，当前是闰", iMonth, "月");
                    } else {
                        daysOfMonth = this.monthDays(this.year, iMonth);
                    }
                    offset -= daysOfMonth;
                    if (this.leap && iMonth == (leapMonth + 1)) {
                        this.leap = false;
                    }
                    if (!this.leap) {
                        monCyl++;
                    }
                }

                if (offset == 0 && leapMonth > 0 && iMonth == leapMonth + 1) {
                    if (this.leap) {
                        this.leap = false;
                    } else {
                        this.leap = true;
                        --iMonth;
                        --monCyl;
                    }
                }

                if (offset < 0) {
                    offset += daysOfMonth;
                    --iMonth;
                    --monCyl;
                }

                this.month = iMonth;
                this.day = offset + 1;
                console.log("DEBUG: 计算出的农历月份:", this.month, (this.leap ? "(闰月)" : ""));
                console.log("DEBUG: 计算出的农历日期:", this.day);
                console.log("=== DEBUG: BaZi.init 农历计算完成 ===");
            }

            yearDays(year) {
                let sum = 348;
                for (let i = 0x8000; i > 0x8; i >>= 1) {
                    if ((lunarInfo[year - 1900] & i) !== 0) sum += 1;
                }
                return sum + this.leapDays(year);
            }

            leapDays(year) {
                if (this.leapMonth(year) !== 0) {
                    if ((lunarInfo[year - 1900] & 0x10000) !== 0) {
                        return 30;
                    } else {
                        return 29;
                    }
                } else {
                    return 0;
                }
            }

            leapMonth(year) {
                return lunarInfo[year - 1900] & 0xf;
            }

            monthDays(year, month) {
                if ((lunarInfo[year - 1900] & (0x10000 >> month)) === 0) {
                    return 29;
                } else {
                    return 30;
                }
            }

            getYear() {
                return this.getYearStr(this.year);
            }

            getMonth() {
                return chineseNumber[this.month - 1];
            }

            getDay() {
                return this.getChinaDayString(this.day);
            }

            getYearGanZhi(hour) {
                console.log("=== DEBUG: getYearGanZhi 开始计算 ===");
                const solarYear = this.cal.getFullYear();
                const solarMonth = this.cal.getMonth(); // 0-11
                const solarDay = this.cal.getDate();
                const solarHour = this.cal.getHours();
                const solarMinute = this.cal.getMinutes();
                console.log("DEBUG: 输入日期:", this.cal.toLocaleString('zh-CN'));
                console.log("DEBUG: 公历年份:", solarYear, "月份:", solarMonth + 1, "日期:", solarDay);
                console.log("DEBUG: 时辰索引:", hour);
                
                // 年柱：根据立春（solar term 2）的精确时间判断
                const term2Time = Lunar.getSolarTermTime(solarYear, 2); // 立春时间
                console.log("DEBUG: 立春时间:", term2Time.toLocaleString('zh-CN'));
                console.log("DEBUG: 当前时间是否早于立春:", this.cal < term2Time);
                
                let baziYear = solarYear;
                if (this.cal < term2Time) {
                    // 如果当前时间早于立春，用上一年的年柱
                    baziYear = solarYear - 1;
                    console.log("DEBUG: 使用上一年的年柱，年份:", baziYear);
                } else {
                    console.log("DEBUG: 使用当前年份的年柱，年份:", baziYear);
                }
                let idx = (baziYear - 1864) % 60;
                const y = BaZi.jiazhi[idx];
                console.log("DEBUG: 年柱索引:", idx, "年柱:", y);

                // 月柱：根据节气判断
                // 八字月支对应关系（以节气为界）：
                // 正月(寅月): 立春(2) -> 惊蛰(4)之前
                // 二月(卯月): 惊蛰(4) -> 清明(6)之前
                // 三月(辰月): 清明(6) -> 立夏(8)之前
                // 四月(巳月): 立夏(8) -> 芒种(10)之前
                // 五月(午月): 芒种(10) -> 小暑(12)之前
                // 六月(未月): 小暑(12) -> 立秋(14)之前
                // 七月(申月): 立秋(14) -> 白露(16)之前
                // 八月(酉月): 白露(16) -> 寒露(18)之前
                // 九月(戌月): 寒露(18) -> 立冬(20)之前
                // 十月(亥月): 立冬(20) -> 大雪(22)之前
                // 十一月(子月): 大雪(22) -> 小寒(0)之前（跨年）
                // 十二月(丑月): 小寒(0) -> 立春(2)之前
                
                // 确定当前时间在哪个节气区间
                let monthZhiIndex = -1;
                
                // 节气索引到月支的映射
                // 节气索引: 0(小寒)->丑(1), 2(立春)->寅(2), 4(惊蛰)->卯(3), 6(清明)->辰(4), 
                // 8(立夏)->巳(5), 10(芒种)->午(6), 12(小暑)->未(7), 14(立秋)->申(8), 
                // 16(白露)->酉(9), 18(寒露)->戌(10), 20(立冬)->亥(11), 22(大雪)->子(0)
                const termToZhi = {
                    0: 1,   // 小寒 -> 丑月
                    2: 2,   // 立春 -> 寅月
                    4: 3,   // 惊蛰 -> 卯月
                    6: 4,   // 清明 -> 辰月
                    8: 5,   // 立夏 -> 巳月
                    10: 6,  // 芒种 -> 午月
                    12: 7,  // 小暑 -> 未月
                    14: 8,  // 立秋 -> 申月
                    16: 9,  // 白露 -> 酉月
                    18: 10, // 寒露 -> 戌月
                    20: 11, // 立冬 -> 亥月
                    22: 0   // 大雪 -> 子月
                };
                
                // 检查所有节气区间
                const termKeys = [0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22];
                for (let i = 0; i < termKeys.length; i++) {
                    const currentTerm = termKeys[i];
                    const nextTerm = i < termKeys.length - 1 ? termKeys[i + 1] : 0; // 最后一个节气后是小寒（跨年）
                    
                    const termTime = Lunar.getSolarTermTime(solarYear, currentTerm);
                    let nextTermTime;
                    if (nextTerm === 0 && currentTerm !== 0) {
                        // 跨年情况：大雪(22)之后是小寒(0)，需要下一年的小寒
                        nextTermTime = Lunar.getSolarTermTime(solarYear + 1, 0);
                    } else {
                        nextTermTime = Lunar.getSolarTermTime(solarYear, nextTerm);
                    }
                    
                    if (this.cal >= termTime && this.cal < nextTermTime) {
                        monthZhiIndex = termToZhi[currentTerm];
                        console.log("DEBUG: 找到节气区间 - 节气索引:", currentTerm, "月支索引:", monthZhiIndex, "月支:", Zhi[monthZhiIndex]);
                        break;
                    }
                }
                
                // 如果还没找到，检查跨年的情况（大雪到小寒之间）
                if (monthZhiIndex === -1) {
                    const term22 = Lunar.getSolarTermTime(solarYear, 22); // 大雪
                    const nextYearTerm0 = Lunar.getSolarTermTime(solarYear + 1, 0); // 下一年的小寒
                    if (this.cal >= term22 && this.cal < nextYearTerm0) {
                        monthZhiIndex = 0; // 子月
                        console.log("DEBUG: 跨年情况 - 大雪到小寒之间，子月");
                    }
                }
                
                // 如果仍然没找到，使用默认值（不应该发生）
                if (monthZhiIndex === -1) {
                    console.error("DEBUG: 无法确定月支，使用默认值");
                    monthZhiIndex = 0;
                }
                
                console.log("DEBUG: 最终确定的月支索引:", monthZhiIndex, "月支:", Zhi[monthZhiIndex]);
                
                // 月干：根据年干推算（五虎遁）
                // 五虎遁口诀：甲己之年丙作首，乙庚之年戊为头，丙辛之年寻庚起，丁壬壬寅顺水流，若问戊癸何处起，甲寅之上好追求
                // 即：年干为甲或己，正月从丙开始；年干为乙或庚，正月从戊开始；等等
                idx = idx % 5; // 年干在十天干中的位置（0-4）
                const idxm = (idx + 1) * 2 % 10; // 五虎遁的起始天干索引
                // 五虎遁是从寅月开始计算的，所以需要将月支转换为从寅月开始的索引
                // 月支索引：子(0), 丑(1), 寅(2), 卯(3), 辰(4), 巳(5), 午(6), 未(7), 申(8), 酉(9), 戌(10), 亥(11)
                // 转换为从寅月开始：寅(2)->0, 卯(3)->1, 辰(4)->2, ..., 子(0)->10, 丑(1)->11
                const monthIndexForGan = (monthZhiIndex + 10) % 12; // 将月支转换为从寅月开始的索引（寅=0, 卯=1, ...）
                const monthGanIndex = (idxm + monthIndexForGan) % 10;
                const m = Gan[monthGanIndex] + Zhi[monthZhiIndex];
                
                console.log("DEBUG: 月柱计算 - 年干索引:", idx, "五虎遁起始:", idxm, "月支索引:", monthZhiIndex, "月支索引(五虎遁):", monthIndexForGan, "月干索引:", monthGanIndex);
                console.log("DEBUG: 月柱:", m);

                // 日柱：根据日期计算
                const offset = (Math.floor((this.cal - this.baseDate) / 86400000) + 40) % 60;
                const d = BaZi.jiazhi[offset];
                console.log("DEBUG: 日柱偏移:", offset, "日柱:", d);

                // 时柱：根据日干和时辰计算（五鼠遁）
                const dayGanIndex = offset % 10;
                const hourGanIndex = (dayGanIndex % 5 * 2 + hour) % 10;
                const h = Gan[hourGanIndex] + Zhi[hour % 12];
                console.log("DEBUG: 时柱计算 - 日干索引:", dayGanIndex, "时干索引:", hourGanIndex, "时支索引:", hour % 12, "时柱:", h);
                
                const result = `${y},${m},${d},${h}`;
                console.log("DEBUG: 完整八字结果:", result);
                console.log("=== DEBUG: getYearGanZhi 计算完成 ===");
                return result;
            }

            animalsYear() {
                const Animals = ["鼠", "牛", "虎", "兔", "龙", "蛇", "马", "羊", "猴", "鸡", "狗", "猪"];
                return Animals[(this.year - 4) % 12];
            }

            getYearStr(year) {
                const chineseword = ["零", "一", "二", "三", "四", "五", "六", "七", "八", "九"];
                let ys = "";
                ys += chineseword[Math.floor(year / 1000)];
                year %= 1000;
                ys += chineseword[Math.floor(year / 100)];
                year %= 100;
                ys += chineseword[Math.floor(year / 10)];
                year %= 10;
                ys += chineseword[year];
                return ys;
            }

            getChinaDayString(day) {
                const chineseTen = ["初", "十", "廿", "卅"];
                const n = day % 10 === 0 ? 9 : day % 10 - 1;
                if (day > 30) return "";
                if (day === 10) return "初十";
                return chineseTen[Math.floor(day / 10)] + chineseNumber[n];
            }

            toString() {
                return `${this.getYearStr(this.year)}年${this.leap ? "闰" : ""}${chineseNumber[this.month - 1]}月${this.getChinaDayString(this.day)}`;
            }
        }
        
        BaZi.jiazhi = [
            "甲子", "乙丑", "丙寅", "丁卯", "戊辰", "己巳", "庚午", "辛未", "壬申", "癸酉",
            "甲戌", "乙亥", "丙子", "丁丑", "戊寅", "己卯", "庚辰", "辛巳", "壬午", "癸未",
            "甲申", "乙酉", "丙戌", "丁亥", "戊子", "己丑", "庚寅", "辛卯", "壬辰", "癸巳",
            "甲午", "乙未", "丙申", "丁酉", "戊戌", "己亥", "庚子", "辛丑", "壬寅", "癸卯",
            "甲辰", "乙巳", "丙午", "丁未", "戊申", "己酉", "庚戌", "辛亥", "壬子", "癸丑",
            "甲寅", "乙卯", "丙辰", "丁巳", "戊午", "己未", "庚申", "辛酉", "壬戌", "癸亥"
        ];
        // --- END: BAZI.JS ---
    
        // --- START: PAIPANFINAL.JS ---
        class PaiPanFinal {
            constructor() {
                
            }

            getBazi(cal, isman) {
                console.log("=== DEBUG: PaiPanFinal.getBazi 开始计算 ===");
                console.log("DEBUG: 输入日期时间:", cal.toLocaleString('zh-CN'));
                console.log("DEBUG: 年份:", cal.getFullYear(), "月份:", cal.getMonth() + 1, "日期:", cal.getDate());
                console.log("DEBUG: 小时:", cal.getHours(), "分钟:", cal.getMinutes());
                
                let lunar = new BaZi(cal);
                let lunaryue = new Lunar(cal);
                let result = Array(10).fill("");
                let time = Math.floor(cal.getHours() / 2);
                console.log("DEBUG: 时辰索引 (Math.floor(小时/2)):", time, "对应时辰:", Zhi[time % 12]);

                // 获取生肖
                let GanZhi = lunar.getYearGanZhi(time); // 取八字
                console.log("DEBUG: getYearGanZhi 返回的完整八字:", GanZhi);
                let tempchar = GanZhi.split(",");
                let ganziyear = tempchar[0]; // 年柱
                let ganzimonth = tempchar[1]; // 月柱
                let ganziday = tempchar[2]; // 日柱
                let ganzitime = tempchar[3]; // 时柱
                console.log("DEBUG: 解析后的八字 - 年柱:", ganziyear, "月柱:", ganzimonth, "日柱:", ganziday, "时柱:", ganzitime);

                // 示例用法
                const chineseInput = lunar.animalsYear(); // 输入一个中文的生肖名称
                const englishOutput = translateZodiac(chineseInput);
                console.log("DEBUG: 生肖:", chineseInput, "->", englishOutput);
                result[0] = englishOutput ;
                result[1] = ganziyear.charAt(0); // 年干
                result[2] = ganziyear.charAt(1); // 年支
                result[3] = ganzimonth.charAt(0); // 月干
                result[4] = ganzimonth.charAt(1); // 月支
                result[5] = ganziday.charAt(0); // 日干
                result[6] = ganziday.charAt(1); // 日支
                result[7] = ganzitime.charAt(0); // 时干
                result[8] = ganzitime.charAt(1); // 时支

                const baziString = `${result[1]}${result[2]} ${result[3]}${result[4]} ${result[5]}${result[6]} ${result[7]}${result[8]}`;
                console.log("DEBUG: 最终八字数组:", result);
                console.log("DEBUG: 最终八字字符串:", baziString);
                console.log("=== DEBUG: PaiPanFinal.getBazi 计算完成 ===");
                return result;
            }
        }
        function translateZodiac(chineseZodiac) {
            const zodiacMap = {
                "鼠": "Rat",
                "牛": "Ox",
                "虎": "Tiger",
                "兔": "Rabbit",
                "龙": "Dragon",
                "蛇": "Snake",
                "马": "Horse",
                "羊": "Goat",
                "猴": "Monkey",
                "鸡": "Rooster",
                "狗": "Dog",
                "猪": "Pig"
            };

            return zodiacMap[chineseZodiac] || "Unknown zodiac";
        }
        // (SAMPLE CODE DELETED HERE)
        // --- END: PAIPANFINAL.JS ---
    
        // --- START: DEALBAZI.JS ---
        function getTianGanTraits(tianGan) {
            const tianGanTraits = {
                "甲": "Strong-willed, upright, and ambitious, like a towering tree. However, can be stubborn, inflexible, and overly aggressive.",
                "乙": "Gentle, adaptable, and creative, like a graceful vine. However, may be indecisive, overly sensitive, and prone to self-doubt.",
                "丙": "Optimistic, enthusiastic, and passionate, like the blazing sun. However, can be impulsive, impatient, and easily frustrated.",
                "丁": "Thoughtful, caring, and resourceful, like a lamp in the dark. However, may be overly cautious, overthink, and emotionally vulnerable.",
                "戊": "Stable, dependable, and protective, like solid walls. However, can be rigid, resistant to change, and overly protective.",
                "己": "Empathetic, nurturing, and patient, like the earth. However, may be overly accommodating, lack assertiveness, and prone to self-sacrifice.",
                "庚": "Resolute, determined, and sharp-minded, like a blade. However, can be harsh, uncompromising, and overly critical.",
                "辛": "Delicate, elegant, and meticulous, like fine silver. However, may be overly perfectionistic, hesitant, and lack spontaneity.",
                "壬": "Bold, visionary, and dynamic, like a grand river. However, can be restless, overly ambitious, and prone to emotional outbursts.",
                "癸": "Quiet, introspective, and intuitive, like a gentle stream. However, may be overly introverted, avoid confrontation, and lack initiative."
            };
            return tianGanTraits[tianGan] || "Invalid input: Please enter a valid Heavenly Stem character.";
        }
        
        function getDiZhiPersonality(diZhi) {
            const diZhiPersonality = {
                "子": "Smart, adaptable, and charming, but can be secretive and restless.",
                "丑": "Hardworking, reliable, and patient, but can be overly cautious and stubborn.",
                "寅": "Ambitious, confident, and brave, but may be impulsive and aggressive.",
                "卯": "Gentle, kind, and artistic, but can be overly sensitive and indecisive.",
                "辰": "Charismatic, imaginative, and resourceful, but can be proud and unpredictable.",
                "巳": "Wise, passionate, and intuitive, but may be jealous and manipulative.",
                "午": "Energetic, enthusiastic, and open-hearted, but can be impatient and reckless.",
                "未": "Compassionate, creative, and dependable, but may be shy and overly self-critical.",
                "申": "Clever, versatile, and curious, but can be mischievous and unreliable.",
                "酉": "Diligent, detail-oriented, and independent, but may be vain and critical.",
                "戌": "Loyal, honest, and protective, but can be pessimistic and stubborn.",
                "亥": "Compassionate, intuitive, and idealistic, but may be naive and escapist."
            };
            return diZhiPersonality[diZhi] || "Invalid input: Please enter a valid Earthly Branch character.";
        }
        
        function getRiYuanDescription(tianGan) {
            const tianGanMap = {
                "甲": "A towering tree under the vast sky",
                "乙": "A winding and graceful vine",
                "丙": "The blazing and radiant sun",
                "丁": "A lamp in the dark night",
                "戊": "Solid walls and sturdy dikes",
                "己": "The nurturing earth embracing all",
                "庚": "A sharp and imposing blade or axe",
                "辛": "Delicate and exquisite silver jewelry",
                "壬": "A grand and majestic river",
                "癸": "A gentle and quiet flowing stream"
            };
            return tianGanMap[tianGan] || "Invalid input: Please enter a valid Heavenly Stem character.";
        }
        
        function transformGanZhiToWuXing(inputString) {
            const ganMapping = {
                '金': ['庚', '辛'],
                '木': ['甲', '乙'],
                '水': ['壬', '癸'],
                '火': ['丙', '丁'],
                '土': ['戊', '己']
            };
            const zhiMapping = {
                '金': ['申', '酉'],
                '木': ['寅', '卯'],
                '水': ['子', '亥'],
                '火': ['巳', '午'],
                '土': ['辰', '戌', '丑', '未']
            };
            let result = '';
            for (let char of inputString) {
                if (/^[a-zA-Z]+$/.test(char)) {
                    continue;
                }
                let replaced = false;
                for (let [wuXing, ganList] of Object.entries(ganMapping)) {
                    if (ganList.includes(char)) {
                        result += wuXing;
                        replaced = true;
                        break;
                    }
                }
                if (!replaced) {
                    for (let [wuXing, zhiList] of Object.entries(zhiMapping)) {
                        if (zhiList.includes(char)) {
                            result += wuXing;
                            replaced = true;
                            break;
                        }
                    }
                }
                if (!replaced) {
                    result += char;
                }
            }
            return result;
        }
        
        function determineConfidence(inputString) {
            if (!inputString || typeof inputString !== 'string') {
                console.error('determineConfidence: inputString is invalid:', inputString);
                return 'NOT a confident';
            }
            
            const conditions = {
                '金': ['金', '土'],
                '水': ['水', '金'],
                '木': ['木', '水'],
                '火': ['火', '木'],
                '土': ['土', '火']
            };
            
            const element4 = inputString[3];
            const element5 = inputString[4];
            const element6 = inputString[5];
            
            // Check if element5 exists and is a valid key in conditions
            if (!element5 || !conditions[element5]) {
                console.warn('determineConfidence: element5 is invalid or not in conditions:', element5, 'inputString:', inputString);
                return 'NOT a confident';
            }
            
            if (element5 && conditions[element5] && (conditions[element5].includes(element4) || conditions[element5].includes(element6))) {
                return 'a confident';
            } else {
                return 'NOT a confident';
            }
        }
        
        function checkElementInString(element, inputString) {
            if (inputString && inputString.includes(element)) {
                return true;
            } else {
                return false;
            }
        }
        
        function checkCharacterAtPosition(char, inputString, position) {
            if (position < 1 || position > inputString.length) {
                return false;
            }
            const charAtPosition = inputString[position - 1];
            return char === charAtPosition ? true : false;
        }
        
        function analyzeWealth(input) {
            const selfPosition = 5;
            const 克制关系 = {
                '金': '木',
                '水': '火',
                '木': '土',
                '火': '金',
                '土': '水'
            };
            if (!input || input.length < selfPosition) {
                return "Unable to analyze wealth - insufficient data.";
            }
            const selfElement = input[selfPosition - 1];
            const wealthElement = 克制关系[selfElement];
            const wealthIndices = input.split('').reduce((indices, char, index) => {
                if (char === wealthElement) indices.push(index + 1);
                return indices;
            }, []);
            let result;
            if (wealthIndices.includes(selfPosition - 1) || wealthIndices.includes(selfPosition + 1)) {
                result = "You highly value wealth.";
            } else if (wealthIndices.length === 0) {
                result = "You don't value wealth at all.";
            } else if ([1, 3].some(i => wealthIndices.includes(i)) && !wealthIndices.includes(2)) {
                result = "You seem to value wealth on the surface, but you don't actually value it.";
            } else if (!wealthIndices.includes(1) && wealthIndices.includes(2)) {
                result = "You don't appear to value wealth, but you actually do.";
            } else {
                result = "You care about wealth, but not that much.";
            }
            return result;
        }
        
        function analyzePurpose(input) {
            const selfPosition = 5;
            const 克制关系 = {
                '金': '木',
                '水': '火',
                '木': '土',
                '火': '金',
                '土': '水'
            };
            if (!input || input.length < selfPosition) {
                return "Unable to analyze purpose - insufficient data.";
            }
            const selfElement = input[selfPosition - 1];
            const wealthElement = 克制关系[selfElement];
            const wealthIndices = input.split('').reduce((indices, char, index) => {
                if (char === wealthElement) indices.push(index + 1);
                return indices;
            }, []);
            let result;
            if (wealthIndices.includes(selfPosition - 1) || wealthIndices.includes(selfPosition + 1)) {
                result = "You have a strong sense of purpose.";
            } else if (wealthIndices.length === 0) {
                result = "You have no sense of purpose at all.";
            } else if ([1, 3].some(i => wealthIndices.includes(i)) && !wealthIndices.includes(2)) {
                result = "You seem to prioritize goals on the surface, but deep down, you don't actually value them.";
            } else if (!wealthIndices.includes(1) && wealthIndices.includes(2)) {
                result = "You don't seem to prioritize goals on the surface, but deep down, you do value them.";
            } else {
                result = "You do have sense of purpose, but not that much.";
            }
            return result;
        }
        
        function analyzeOpinion(input) {
            const selfPosition = 5;
            const 印生关系 = {
                '金': '土',
                '水': '金',
                '木': '水',
                '火': '木',
                '土': '火'
            };
            if (!input || input.length < selfPosition) {
                return "Unable to analyze opinion - insufficient data.";
            }
            const selfElement = input[selfPosition - 1];
            const wealthElement = 印生关系[selfElement];
            const wealthIndices = input.split('').reduce((indices, char, index) => {
                if (char === wealthElement) indices.push(index + 1);
                return indices;
            }, []);
            let result;
            if (wealthIndices.includes(selfPosition - 1) || wealthIndices.includes(selfPosition + 1)) {
                result = "You are very good at listening to others' perspectives.";
            } else if (wealthIndices.length === 0) {
                result = "You don't listen to others' perspectives at all.";
            } else if ([1, 3].some(i => wealthIndices.includes(i)) && !wealthIndices.includes(2)) {
                result = "You appear to like listening to others' opinions on the surface, but you don't really take them in.";
            } else if (!wealthIndices.includes(1) && wealthIndices.includes(2)) {
                result = "You seem not to like listening to others' opinions on the surface, but you actually take them in.";
            } else {
                result = "Sometimes you listen to others' opinions, and sometimes you don't.";
            }
            return result;
        }
        
        function analyzeSupport(input) {
            const selfPosition = 5;
            const 印生关系 = {
                '金': '土',
                '水': '金',
                '木': '水',
                '火': '木',
                '土': '火'
            };
            if (!input || input.length < selfPosition) {
                return "Unable to analyze support - insufficient data.";
            }
            const selfElement = input[selfPosition - 1];
            const wealthElement = 印生关系[selfElement];
            const wealthIndices = input.split('').reduce((indices, char, index) => {
                if (char === wealthElement) indices.push(index + 1);
                return indices;
            }, []);
            let result;
            if (wealthIndices.includes(selfPosition - 1) || wealthIndices.includes(selfPosition + 1)) {
                result = "Benefactors are very likely to extend their support to you.";
            } else if (wealthIndices.length === 0) {
                result = "It seems improbable that help will come your way.";
            } else {
                result = "Sometimes help comes your way, but other times it doesn't.";
            }
            return result;
        }
        
        function analyzeBoyPopular(input) {
            const selfPosition = 5;
            const 克制关系 = {
                '金': '木',
                '水': '火',
                '木': '土',
                '火': '金',
                '土': '水'
            };
            if (!input || input.length < selfPosition) {
                return "Unable to analyze popularity - insufficient data.";
            }
            const selfElement = input[selfPosition - 1];
            const wealthElement = 克制关系[selfElement];
            const wealthIndices = String(input).split('').reduce((indices, char, index) => {
                if (char === wealthElement) indices.push(index + 1);
                return indices;
            }, []);
            let result;
            if (wealthIndices.includes(selfPosition - 1) || wealthIndices.includes(selfPosition + 1)) {
                result = "You have a natural charm that draws the attention of the opposite sex.";
            } else if (wealthIndices.length === 0) {
                result = "You are not particularly sought after by the opposite sex.";
            } else {
                result = "Your charm is there, but it's not something that stands out significantly.";
            }
            return result;
        }
        
        function analyzeGirlPopular(input) {
            const selfPosition = 5;
            const 克制关系 = {
                '金': '火',
                '水': '土',
                '木': '金',
                '火': '水',
                '土': '木'
            };
            if (!input || input.length < selfPosition) {
                return "Unable to analyze popularity - insufficient data.";
            }
            const selfElement = input[selfPosition - 1];
            const wealthElement = 克制关系[selfElement];
            const wealthIndices = String(input).split('').reduce((indices, char, index) => {
                if (char === wealthElement) indices.push(index + 1);
                return indices;
            }, []);
            let result;
            if (wealthIndices.includes(selfPosition - 1) || wealthIndices.includes(selfPosition + 1)) {
                result = "You have a natural charm that draws the attention of the opposite sex.";
            } else if (wealthIndices.length === 0) {
                result = "You are not particularly sought after by the opposite sex.";
            } else {
                result = "Your charm is there, but it's not something that stands out significantly.";
            }
            return result;
        }
        
        function analyzeSexPopular(input, gender) {
            console.log("input:", input, "gender:", gender);
            if (gender === "Male") {
                return analyzeBoyPopular(input);
            } else {
                return analyzeGirlPopular(input);
            }
        }
        
        function analyzeIdealPartner(input, gender) {
            const tianGanWuXing = {
                '甲': '木', '乙': '木', '丙': '火', '丁': '火', '戊': '土',
                '己': '土', '庚': '金', '辛': '金', '壬': '水', '癸': '水'
            };
            const diZhiToTianGan = {
                '子': ['癸'], '丑': ['己', '癸', '辛'], '寅': ['甲', '丙', '戊'],
                '卯': ['乙'], '辰': ['戊', '乙', '癸'], '巳': ['丙', '庚', '戊'],
                '午': ['丁', '己'], '未': ['己', '乙', '丁'], '申': ['庚', '壬', '戊'],
                '酉': ['辛'], '戌': ['戊', '丁', '辛'], '亥': ['壬', '甲']
            };
            const wuXingRelationship = {
                '木': { 克: '土', 生: '火', 被克: '金', 被生: '水' },
                '火': { 克: '金', 生: '土', 被克: '水', 被生: '木' },
                '土': { 克: '水', 生: '金', 被克: '木', 被生: '火' },
                '金': { 克: '木', 生: '水', 被克: '火', 被生: '土' },
                '水': { 克: '火', 生: '木', 被克: '土', 被生: '金' }
            };
            const elements = String(input).split(',');
            if (elements.length < 7) {
                return 'Unable to analyze ideal partner - insufficient data.';
            }
            const targetTianGan = elements[5];
            const targetWuXing = tianGanWuXing[targetTianGan];
            const targetDiZhi = elements[6];
            const possibleTianGan = diZhiToTianGan[targetDiZhi];
            if (!targetWuXing || !possibleTianGan) {
                return 'Unable to analyze ideal partner - invalid input.';
            }
            const results = possibleTianGan.map(tianGan => {
                const wuXing = tianGanWuXing[tianGan];
                if (wuXing === wuXingRelationship[targetWuXing].克) {
                    return "You hope your partner can bring you financial prosperity, and you can have control over your partner.";
                } else if (wuXing === wuXingRelationship[targetWuXing].被克) {
                    return "You hope your partner can appropriately regulate your behavior in life.";
                } else if (wuXing === wuXingRelationship[targetWuXing].生) {
                    return "You hope you find someone you love as your spouse, someone you can confide in.";
                } else if (wuXing === wuXingRelationship[targetWuXing].被生) {
                    return "You hope to find someone who loves you as your spouse and is very supportive of you.";
                } else {
                    return "You hope to find someone like you, like a close brother, who can share joys and hardships with you.";
                }
            });
            return results.join('\n\n');
        }
        // --- END: DEALBAZI.JS ---
    
        // --- START: SCRIPT.JS (MODIFIED) ---
        const userInteraction = {
            birthday: null,
            currentCategory: null,
            bazi: null,
            riyuan: null,
            yuezhi: null,
            baziWuxing: null,
            gender: null,
        };
        
        // Categories and questions
        const categories = {
            Self: [
                { id: 'ioe', text: 'Am I an Introvert (I) or an Extrovert (E)?', handler: 'handleIOEQuestion' },
                { id: 'zodiac', text: 'What is my Chinese zodiac sign?', handler: 'handleZodiacQuestion' },
                { id: 'swipe', text: 'Please Swipe Left for More Questions', handler: 'handleSwipeQuestion' },
                { id: 'nature', text: 'If my personality were reflected in nature, would I be a tree, the sun, or a stream?', handler: 'handleNatureQuestion' },
                { id: 'confident', text: 'Am I a confident person?', handler: 'handleConfidentQuestion' },
                { id: 'calm', text: 'Am I someone who can handle situations calmly?', handler: 'handleCalmQuestion' },
                { id: 'adaptable', text: 'Am I adaptable when handling situations?', handler: 'handleAdaptableQuestion' },
                { id: 'courageous', text: 'Am I a courageous person?', handler: 'handleCourageousQuestion' },
                { id: 'compassionate', text: 'Am I a compassionate person?', handler: 'handleCompassionateQuestion' },
                { id: 'promises', text: 'Am I someone who values promises?', handler: 'handlePromisesQuestion' },
                { id: 'stranger', text: 'What impression do I leave on strangers?', handler: 'handleStrangerQuestion' },
                { id: 'familiar', text: 'How am I perceived by those who are familiar with me?', handler: 'handleFamiliarQuestion' },
                { id: 'myself', text: 'What is my true inner self?', handler: 'handleMyselfQuestion' }
            ],
            Love: [
                { id: 'ideal', text: "What are my expectations for an ideal partner?", handler: 'handleIdealPartnerQuestion' },
                { id: 'sexpopular', text: 'Am I someone who is popular with the opposite sex?', handler: 'handleSexPopularQuestion' }
            ],
            Wealth: [
                { id: 'wealth', text: 'Do I value wealth?', handler: 'handleWealthQuestion' },
                { id: 'purpose', text: 'Do I have a sense of purpose in what I do?', handler: 'handlePurposeQuestion' },
                { id: 'opinions', text: "Am I someone who is good at listening to others' opinions?", handler: 'handleOpinionsQuestion' },
                { id: 'support', text: "Do I have a higher chance of getting help from benefactors?", handler: 'handleSupportQuestion' }
            ],
        };
        
        // Load categories
        function loadCategories() {
            const optionsDiv = document.getElementById('options');
            if (!optionsDiv) {
                console.error("ERROR: options element not found.");
                return;
            }
            optionsDiv.innerHTML = '';
            
            Object.keys(categories).forEach((category) => {
                const button = document.createElement('button');
                button.textContent = category;
                button.onclick = () => loadQuestions(category);
                optionsDiv.appendChild(button);
            });
            
            const modifyButton = document.createElement('button');
            modifyButton.textContent = 'Modify Birthday & Gender';
            modifyButton.onclick = showInputGroup;
            optionsDiv.appendChild(modifyButton);
            
            const deepseekButton = document.createElement('button');
            deepseekButton.textContent = '🔮 Fate Free Inquiry';
            deepseekButton.onclick = toggleDeepSeekChat;
            optionsDiv.appendChild(deepseekButton);
        }
        
        // Toggle DeepSeek chat interface
        function toggleDeepSeekChat() {
            const deepseekGroup = document.getElementById('deepseek-chat-group');
            if (!deepseekGroup) return;
            
            if (deepseekGroup.style.display === 'none' || !deepseekGroup.style.display) {
                deepseekGroup.style.display = 'flex';
                // Focus on input
                const deepseekInput = document.getElementById('deepseek-input');
                if (deepseekInput) {
                    deepseekInput.focus();
                }
            } else {
                deepseekGroup.style.display = 'none';
            }
        }
        
        // Backend API endpoint - WordPress REST API
        // If index1.html is on the same domain as WordPress, use relative path:
        const DEEPSEEK_API_PROXY = '/wp-json/deepseek/v1/chat';
        
        // If index1.html is on a different domain, use full URL:
        // const DEEPSEEK_API_PROXY = 'https://yourwordpress.com/wp-json/deepseek/v1/chat';
        
        // TODO: Update this to match your WordPress installation
        
        // Load questions for a selected category
        function loadQuestions(category) {
            userInteraction.currentCategory = category;
            const optionsDiv = document.getElementById('options');
            if (!optionsDiv) return;
            optionsDiv.innerHTML = '';
            
            categories[category].forEach((question) => {
                const button = document.createElement('button');
                button.textContent = question.text;
                button.onclick = () => {
                    handleQuestion(question.handler);
                };
                optionsDiv.appendChild(button);
            });
            
            const backButton = document.createElement('button');
            backButton.textContent = 'Back to Categories';
            backButton.onclick = loadCategories;
            optionsDiv.appendChild(backButton);
        }
        
        function handleQuestion(handlerName) {
            if (typeof window[handlerName] === 'function') {
                window[handlerName]();
            } else {
                appendMessage('Error: Invalid handler specified.', 'bot');
            }
        }
        
        // Save user's birthday
        function saveUserBirthdayGender(bd, gender) {
            if (!bd) {
                console.warn("LOG: Cannot save - birthday is empty");
                return;
            }
            const birthday = bd + '.' + (gender || '');
            console.log("LOG: Saving birthday to storage:", birthday);
            if (window.parent !== window) {
                window.parent.postMessage({ action: 'saveBirthday', birthday }, '*');
            } else {
                localStorage.setItem('userBirthday', birthday);
                console.log("LOG: Birthday saved to localStorage:", localStorage.getItem('userBirthday'));
            }
        }
        
        // Update Bazi and Zodiac (simplified - requires full implementation)
        function updateBaziZodiac() {
            if (!userInteraction.birthday) return;
            try {
                if (typeof PaiPanFinal !== 'undefined' && typeof mypaipan !== 'undefined') {
                    const dateObject = new Date(userInteraction.birthday);
                    userInteraction.bazi = mypaipan.getBazi(dateObject, true);
                    // Additional processing would go here
                } else {
                    console.warn("PaiPanFinal not available");
                }
            } catch (e) {
                console.error("Error updating Bazi:", e);
            }
        }
        
        // Gender selection handler
        const genderModal = document.getElementById('genderModal');
        const maleButton = document.getElementById('maleButton');
        const femaleButton = document.getElementById('femaleButton');
        
        if (genderModal && maleButton && femaleButton) {
            document.getElementById('birthday-input').addEventListener('change', () => {
                genderModal.style.display = 'block';
            });
            
            maleButton.addEventListener('click', () => {
                genderModal.style.display = 'none';
                userInteraction.gender = 'Male';
                console.log("LOG: Gender set to Male, birthday:", userInteraction.birthday);
                // If birthday already exists, save the updated combination
                if (userInteraction.birthday) {
                    saveUserBirthdayGender(userInteraction.birthday, userInteraction.gender);
                    updateBaziZodiac();
                }
            });
            
            femaleButton.addEventListener('click', () => {
                genderModal.style.display = 'none';
                userInteraction.gender = 'Female';
                console.log("LOG: Gender set to Female, birthday:", userInteraction.birthday);
                // If birthday already exists, save the updated combination
                if (userInteraction.birthday) {
                    saveUserBirthdayGender(userInteraction.birthday, userInteraction.gender);
                    updateBaziZodiac();
                }
            });
        }
        
        // Send button event listener
        const sendButton = document.getElementById('send-button');
        const birthdayInput = document.getElementById('birthday-input');
        if (sendButton) {
            sendButton.addEventListener('click', sendMessage);
        }
        if (birthdayInput) {
            birthdayInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    sendMessage(e);
                }
            });
        }
        
        // DeepSeek API functions - Calls backend proxy instead of directly calling DeepSeek
        async function callDeepSeekAPI(userMessage) {
            // Check if Bazi and gender are available
            if (!ensureBaziDataAvailable()) {
                appendMessage('Please enter your birthday and gender first.', 'bot');
                return null;
            }
            
            if (!userInteraction.bazi || !userInteraction.gender) {
                appendMessage('Please enter your birthday and gender first.', 'bot');
                return null;
            }
            
            // Format Bazi and gender
            const formattedBazi = formatBaziString(userInteraction.bazi);
            const formattedGender = formatGender(userInteraction.gender);
            
            if (!formattedBazi || !formattedGender) {
                appendMessage('Bazi or gender information is incomplete. Please re-enter your birthday and gender.', 'bot');
                return null;
            }
            
            // Build the prompt with dynamic values
            const systemPrompt = `My question is: ${userMessage}. You are a Bazi (Chinese astrology) master, help me answer this question based on this Bazi chart. The Bazi information is: ${formattedBazi}, Gender: ${formattedGender}. Answer in English, don't use too technical terms, but explain it in a way that Americans can understand. Remove the disclaimer at the end. Use second person, not third person. Do not mention Bazi in the answer. Do not use Chinese characters in the answer. Do not use any other languages in the answer. Keep your answer within 120 words.`;
            
            // Show thinking indicator with fortune-telling style
            const chatBox = document.getElementById('chat-box');
            let thinkingMsg = null;
            if (chatBox) {
                thinkingMsg = document.createElement('div');
                thinkingMsg.className = 'message bot';
                thinkingMsg.textContent = '🔮 Consulting the stars and reading your fate...';
                thinkingMsg.id = 'deepseek-thinking-msg';
                chatBox.appendChild(thinkingMsg);
                chatBox.scrollTop = chatBox.scrollHeight;
            }
            
            try {
                // Call backend proxy (WordPress REST API or independent backend)
                const response = await fetch(DEEPSEEK_API_PROXY, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        message: systemPrompt
                    })
                });
                
                const data = await response.json();
                
                if (!response.ok) {
                    let errorMessage = data.error?.message || `HTTP error! status: ${response.status}`;
                    
                    // Handle specific error codes with user-friendly messages
                    if (response.status === 401) {
                        errorMessage = 'Invalid API Key. Server configuration error.';
                    } else if (response.status === 402) {
                        errorMessage = 'Insufficient Balance. The service account has insufficient credits. Please contact the administrator.';
                    } else if (response.status === 429) {
                        errorMessage = 'Rate limit exceeded. Please wait a moment and try again.';
                    } else if (response.status === 500) {
                        errorMessage = data.message || 'Server error. Please try again later.';
                    } else if (response.status === 503) {
                        errorMessage = 'Service unavailable. The backend server may be down. Please try again later.';
                    }
                    
                    throw new Error(errorMessage);
                }
                
                // Remove thinking message
                if (thinkingMsg && thinkingMsg.parentNode) {
                    thinkingMsg.parentNode.removeChild(thinkingMsg);
                }
                
                // Include the prompt for manual verification (can be hidden in production)
                // Set SHOW_PROMPT_IN_RESPONSE to false when ready for production
                const SHOW_PROMPT_IN_RESPONSE = true; // Change to false for production
                
                let deepseekResponse = data.content || 'No response from DeepSeek.';
                
                // Limit response to 120 words
                function limitWords(text, maxWords) {
                    // Remove extra whitespace and split into words
                    const words = text.trim().split(/\s+/);
                    if (words.length <= maxWords) {
                        return text;
                    }
                    // Take first maxWords words and join them
                    const limitedWords = words.slice(0, maxWords);
                    // Try to end at a sentence boundary if possible
                    let result = limitedWords.join(' ');
                    // If the last character is not punctuation, try to find the last sentence end
                    const lastSentenceEnd = result.lastIndexOf('.');
                    if (lastSentenceEnd > result.length * 0.7) {
                        // If we found a sentence end in the last 30% of the text, use it
                        result = result.substring(0, lastSentenceEnd + 1);
                    } else {
                        // Otherwise, just add ellipsis
                        result = result + '...';
                    }
                    return result;
                }
                
                // Apply word limit to response (only to the actual response, not the prompt)
                const limitedResponse = limitWords(deepseekResponse, 120);
                
                if (SHOW_PROMPT_IN_RESPONSE) {
                    // Return response with prompt for verification
                    return `[PROMPT SENT TO DEEPSEEK]\n${systemPrompt}\n\n[RESPONSE]\n${limitedResponse}`;
                } else {
                    // Return only the response for production
                    return limitedResponse;
                }
            } catch (error) {
                console.error('DeepSeek API Error:', error);
                // Remove thinking message on error
                if (thinkingMsg && thinkingMsg.parentNode) {
                    thinkingMsg.parentNode.removeChild(thinkingMsg);
                }
                
                // Handle network errors
                if (error.message.includes('Failed to fetch') || error.message.includes('NetworkError')) {
                    appendMessage('❌ Unable to connect to the server. Please check if the backend server is running.', 'bot');
                } else {
                    appendMessage(`❌ ${error.message}`, 'bot');
                }
                return null;
            }
        }
        
        // Send message to DeepSeek
        async function sendDeepSeekMessage() {
            const deepseekInput = document.getElementById('deepseek-input');
            
            if (!deepseekInput) return;
            
            const userMessage = deepseekInput.value.trim();
            if (!userMessage) {
                appendMessage('Please enter a message.', 'bot');
                return;
            }
            
            // Display user message
            appendMessage(userMessage, 'user');
            deepseekInput.value = '';
            
            // Call DeepSeek API through backend proxy
            const response = await callDeepSeekAPI(userMessage);
            if (response) {
                displayResponseGradually(response);
            }
        }
        
        // DeepSeek event listeners
        const deepseekSendBtn = document.getElementById('deepseek-send-btn');
        const deepseekInput = document.getElementById('deepseek-input');
        
        if (deepseekSendBtn) {
            deepseekSendBtn.addEventListener('click', sendDeepSeekMessage);
        }
        
        if (deepseekInput) {
            deepseekInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    sendDeepSeekMessage();
                }
            });
        }
        
        // Load saved birthday from localStorage or parent window
        function loadSavedBirthday() {
            if (window.parent !== window) {
                // Iframe mode: try to get from parent (message listener already set up elsewhere)
                window.parent.postMessage({ action: 'fetchBirthday' }, '*');
                // Return false to show input, will be handled by message listener
                return false;
            } else {
                // Standalone mode: get from localStorage
                const savedBirthday = localStorage.getItem('userBirthday');
                if (savedBirthday) {
                    const [birthday, gender] = savedBirthday.split('.');
                    userInteraction.birthday = birthday;
                    userInteraction.gender = gender || null;
                    console.log("LOG: Loaded saved birthday from localStorage:", userInteraction.birthday, "gender:", userInteraction.gender);
                    updateBaziZodiac();
                    appendMessage(`Welcome back! Currently, the provided birthday and gender are: ${savedBirthday}`, 'bot');
                    loadCategories();
                    return true;
                }
            }
            return false;
        }
        
        // --- 最终的、最安全的启动逻辑：等待整个页面加载完毕 ---
        window.onload = function() {
            setTimeout(() => {
                console.log("LOG: STARTING APPLICATION INITIALIZATION...");
                // Try to load saved birthday first
                const hasSavedBirthday = loadSavedBirthday();
                if (!hasSavedBirthday) {
                    // No saved birthday, show welcome message and input
                    appendMessage('Welcome, Seeker. The stars have guided you here. What burden weighs on your heart today?(Type your birthday and gender below to begin):', 'bot');
                    showInputGroup();
                }
            }, 100);
        };
        
        // Question handler functions
        function handleSwipeQuestion(){
            const tooltip = document.getElementById('tooltip');
            if (tooltip) {
                tooltip.style.display = 'block';
                console.log("display indicate...");
                setTimeout(() => {
                    tooltip.style.display = 'none';
                }, 4000);
            }
        }
        
        function getBaziByIndex(bazi, number){
            const parts = String(bazi).split(',');
            if (parts.length >= 6) {
                return parts[number];
            }
            return null;
        }
        
        // Format Bazi string to "年干年支 月干月支 日干日支 时干时支" format
        function formatBaziString(bazi) {
            if (!bazi) return '';
            const parts = String(bazi).split(',');
            // Format: zodiac,年干,年支,月干,月支,日干,日支,时干,时支
            if (parts.length >= 9) {
                // Index: 1=年干, 2=年支, 3=月干, 4=月支, 5=日干, 6=日支, 7=时干, 8=时支
                return `${parts[1]}${parts[2]} ${parts[3]}${parts[4]} ${parts[5]}${parts[6]} ${parts[7]}${parts[8]}`;
            }
            return '';
        }
        
        // Convert gender to Chinese
        function formatGender(gender) {
            if (!gender) return '';
            return gender === 'Male' ? '男' : (gender === 'Female' ? '女' : '');
        }
        
        function getRiYuan(inputString) {
            const parts = String(inputString).split(',');
            if (parts.length >= 6) {
                return parts[5];
            }
            return null;
        }
        
        function getYueZhi(inputString) {
            const parts = String(inputString).split(',');
            if (parts.length >= 6) {
                return parts[4];
            }
            return null;
        }
        
        function adjustTime(inputDate) {
            const inputTime = new Date(inputDate);
            const currentDate = new Date(inputTime.getFullYear(), inputTime.getMonth(), inputTime.getDate());
            const cutoffTime = new Date(currentDate);
            cutoffTime.setHours(22, 59, 0, 0);
            
            if (inputTime > cutoffTime) {
                const nextDay = new Date(currentDate);
                nextDay.setDate(nextDay.getDate() + 1);
                nextDay.setHours(0, 30, 0, 0);
                return nextDay;
            }
            return inputTime;
        }
        
        function checkIOE() {
            const inputChar = userInteraction.riyuan;
            if (!inputChar) return 'Unknown';
            const tianGanE = ['甲', '丙', '戊', '庚', '壬'];
            return tianGanE.includes(inputChar) ? 'Extrovert (E)' : 'Introvert (I)';
        }
        
        function getZodiac() {
            const inputString = userInteraction.bazi;
            if (!inputString) return 'Unknown';
            const parts = String(inputString).split(',');
            if (parts.length >= 6) {
                return parts[0];
            }
            return null;
        }
        
        function handleIOEQuestion() {
            if (!ensureBaziDataAvailable()) {
                appendMessage('Please enter your birthday first.', 'bot');
                return;
            }
            const response = `You likely fall into the ${checkIOE()} category, if you were to take the MBTI test.`;
            displayResponseGradually(response);
        }
        
        function handleZodiacQuestion() {
            if (!ensureBaziDataAvailable()) {
                appendMessage('Please enter your birthday first.', 'bot');
                return;
            }
            const zodiac = getZodiac();
            const response = `Your Chinese zodiac sign is ${zodiac || 'Unknown'}.`;
            displayResponseGradually(response);
        }
        
        function handleNatureQuestion() {
            if (!ensureBaziDataAvailable()) {
                appendMessage('Please enter your birthday first.', 'bot');
                return;
            }
            if (typeof getRiYuanDescription === 'function') {
                const response = `If your personality were reflected in nature, you would be: ${getRiYuanDescription(userInteraction.riyuan)}.`;
                displayResponseGradually(response);
            } else {
                appendMessage('Analysis function not available. Please ensure all dependencies are loaded.', 'bot');
            }
        }
        
        function handleCalmQuestion() {
            if (!ensureBaziDataAvailable()) {
                appendMessage('Please enter your birthday first.', 'bot');
                return;
            }
            let result = '';
            if (typeof checkElementInString === 'function' && typeof checkCharacterAtPosition === 'function') {
                if (checkElementInString('金', userInteraction.baziWuxing) == false) {
                    result = 'You are NOT a calm person at all.';
                } else if (checkCharacterAtPosition('金', userInteraction.baziWuxing, 4) || checkCharacterAtPosition('金', userInteraction.baziWuxing, 5) || checkCharacterAtPosition('金', userInteraction.baziWuxing, 6)) {
                    result = 'You are a typical calm person.';
                } else {
                    result = 'You are somewhat a calm person, but not in a very typical sense.';
                }
            } else {
                result = 'Analysis function not available.';
            }
            displayResponseGradually(result);
        }
        
        function handleConfidentQuestion() {
            if (!ensureBaziDataAvailable()) {
                appendMessage('Please enter your birthday first.', 'bot');
                return;
            }
            if (!userInteraction.baziWuxing) {
                appendMessage('Bazi data is not available. Please re-enter your birthday.', 'bot');
                return;
            }
            if (typeof determineConfidence === 'function') {
                const result = determineConfidence(userInteraction.baziWuxing);
                if (result) {
                    const response = `Actually you are ${result} person.`;
                    displayResponseGradually(response);
                } else {
                    appendMessage('Unable to determine confidence. Please try again.', 'bot');
                }
            } else {
                appendMessage('Analysis function not available.', 'bot');
            }
        }
        
        function handleAdaptableQuestion() {
            if (!ensureBaziDataAvailable()) {
                appendMessage('Please enter your birthday first.', 'bot');
                return;
            }
            let result = '';
            const ele = '水';
            const des = 'adaptable';
            if (typeof checkElementInString === 'function' && typeof checkCharacterAtPosition === 'function') {
                if (checkElementInString(ele, userInteraction.baziWuxing) == false) {
                    result = 'You are NOT an ' + des + ' person at all.';
                } else if (checkCharacterAtPosition(ele, userInteraction.baziWuxing, 4) || checkCharacterAtPosition(ele, userInteraction.baziWuxing, 5) || checkCharacterAtPosition(ele, userInteraction.baziWuxing, 6)) {
                    result = 'You are a typical ' + des + ' person.';
                } else {
                    result = 'You are somewhat an ' + des + ' person, but not in a very typical sense.';
                }
            } else {
                result = 'Analysis function not available.';
            }
            displayResponseGradually(result);
        }
        
        function handleCourageousQuestion() {
            if (!ensureBaziDataAvailable()) {
                appendMessage('Please enter your birthday first.', 'bot');
                return;
            }
            let result = '';
            const ele = '木';
            const des = 'courageous';
            if (typeof checkElementInString === 'function' && typeof checkCharacterAtPosition === 'function') {
                if (checkElementInString(ele, userInteraction.baziWuxing) == false) {
                    result = 'You are NOT a ' + des + ' person at all.';
                } else if (checkCharacterAtPosition(ele, userInteraction.baziWuxing, 4) || checkCharacterAtPosition(ele, userInteraction.baziWuxing, 5) || checkCharacterAtPosition(ele, userInteraction.baziWuxing, 6)) {
                    result = 'You are a typical ' + des + ' person.';
                } else {
                    result = 'You are somewhat a ' + des + ' person, but not in a very typical sense.';
                }
            } else {
                result = 'Analysis function not available.';
            }
            displayResponseGradually(result);
        }
        
        function handleCompassionateQuestion() {
            if (!ensureBaziDataAvailable()) {
                appendMessage('Please enter your birthday first.', 'bot');
                return;
            }
            let result = '';
            const ele = '火';
            const des = 'compassionate';
            if (typeof checkElementInString === 'function' && typeof checkCharacterAtPosition === 'function') {
                if (checkElementInString(ele, userInteraction.baziWuxing) == false) {
                    result = 'You are NOT a ' + des + ' person at all.';
                } else if (checkCharacterAtPosition(ele, userInteraction.baziWuxing, 4) || checkCharacterAtPosition(ele, userInteraction.baziWuxing, 5) || checkCharacterAtPosition(ele, userInteraction.baziWuxing, 6)) {
                    result = 'You are a typical ' + des + ' person.';
                } else {
                    result = 'You are somewhat a ' + des + ' person, but not in a very typical sense.';
                }
            } else {
                result = 'Analysis function not available.';
            }
            displayResponseGradually(result);
        }
        
        function handlePromisesQuestion() {
            if (!ensureBaziDataAvailable()) {
                appendMessage('Please enter your birthday first.', 'bot');
                return;
            }
            let result = '';
            const ele = '土';
            const des = 'commitment-minded';
            if (typeof checkElementInString === 'function' && typeof checkCharacterAtPosition === 'function') {
                if (checkElementInString(ele, userInteraction.baziWuxing) == false) {
                    result = 'You are NOT a ' + des + ' person at all.';
                } else if (checkCharacterAtPosition(ele, userInteraction.baziWuxing, 4) || checkCharacterAtPosition(ele, userInteraction.baziWuxing, 5) || checkCharacterAtPosition(ele, userInteraction.baziWuxing, 6)) {
                    result = 'You are a typical ' + des + ' person.';
                } else {
                    result = 'You are somewhat a ' + des + ' person, but not in a very typical sense.';
                }
            } else {
                result = 'Analysis function not available.';
            }
            displayResponseGradually(result);
        }
        
        function handleMyselfQuestion() {
            if (!ensureBaziDataAvailable()) {
                appendMessage('Please enter your birthday first.', 'bot');
                return;
            }
            if (typeof getDiZhiPersonality === 'function') {
                let result = getDiZhiPersonality(getBaziByIndex(userInteraction.bazi, 4));
                if (getBaziByIndex(userInteraction.bazi, 4) !== getBaziByIndex(userInteraction.bazi, 6)) {
                    result += '\n\n ' + getDiZhiPersonality(getBaziByIndex(userInteraction.bazi, 6));
                }
                if (getBaziByIndex(userInteraction.bazi, 2) !== getBaziByIndex(userInteraction.bazi, 4) && getBaziByIndex(userInteraction.bazi, 2) !== getBaziByIndex(userInteraction.bazi, 6)) {
                    result += '\n\n ' + getDiZhiPersonality(getBaziByIndex(userInteraction.bazi, 2));
                }
                const response = `This is what your true inner personality is like: \n\n ${result}`;
                displayResponseGradually(response);
            } else {
                appendMessage('Analysis function not available.', 'bot');
            }
        }
        
        function handleStrangerQuestion() {
            if (!ensureBaziDataAvailable()) {
                appendMessage('Please enter your birthday first.', 'bot');
                return;
            }
            if (typeof getTianGanTraits === 'function') {
                let result = getTianGanTraits(getBaziByIndex(userInteraction.bazi, 1));
                if (getBaziByIndex(userInteraction.bazi, 1) !== getBaziByIndex(userInteraction.bazi, 3)) {
                    result += '\n\n ' + getTianGanTraits(getBaziByIndex(userInteraction.bazi, 3));
                }
                const response = `This is the impression you leave on people when they first meet you: \n\n ${result}`;
                displayResponseGradually(response);
            } else {
                appendMessage('Analysis function not available.', 'bot');
            }
        }
        
        function handleFamiliarQuestion() {
            if (!ensureBaziDataAvailable()) {
                appendMessage('Please enter your birthday first.', 'bot');
                return;
            }
            if (typeof getTianGanTraits === 'function') {
                const response = `Here's the impression you leave on people who are familiar with you: \n\n ${getTianGanTraits(getBaziByIndex(userInteraction.bazi, 5))}\n\n`;
                displayResponseGradually(response);
            } else {
                appendMessage('Analysis function not available.', 'bot');
            }
        }
        
        // Helper function to ensure Bazi data is available
        function ensureBaziDataAvailable() {
            // First check if birthday exists
            if (!userInteraction.birthday) {
                // Try to load from localStorage
                const savedBirthday = localStorage.getItem('userBirthday');
                if (savedBirthday) {
                    const [birthday, gender] = savedBirthday.split('.');
                    userInteraction.birthday = birthday;
                    if (gender) {
                        userInteraction.gender = gender;
                    }
                    console.log("LOG: Loaded birthday from localStorage:", userInteraction.birthday);
                } else {
                    console.log("LOG: No birthday found in localStorage");
                    return false;
                }
            }
            
            // If birthday exists but bazi data is missing, recalculate
            if (userInteraction.birthday && (!userInteraction.bazi || !userInteraction.baziWuxing)) {
                console.log("LOG: Birthday exists but Bazi data missing, recalculating...");
                updateBaziZodiac();
                // Wait a bit for calculation to complete, then check again
                // If still missing after calculation, at least we have birthday
            }
            
            // Return true if birthday exists (even if bazi calculation failed)
            // This allows the app to continue working with birthday
            if (userInteraction.birthday) {
                console.log("LOG: Birthday available:", userInteraction.birthday, "Bazi:", userInteraction.bazi ? "exists" : "missing", "BaziWuxing:", userInteraction.baziWuxing ? "exists" : "missing");
                return true;
            }
            
            return false;
        }
        
        function handleSexPopularQuestion() {
            if (!ensureBaziDataAvailable() || !userInteraction.gender) {
                appendMessage('Please enter your birthday and gender first.', 'bot');
                return;
            }
            if (typeof analyzeSexPopular === 'function') {
                if (!userInteraction.baziWuxing) {
                    appendMessage('Bazi data is not available. Please re-enter your birthday.', 'bot');
                    return;
                }
                const result = analyzeSexPopular(userInteraction.baziWuxing, userInteraction.gender);
                if (result) {
                    displayResponseGradually(result);
                } else {
                    appendMessage('Unable to analyze popularity. Please try again.', 'bot');
                }
            } else {
                appendMessage('Analysis function not available.', 'bot');
            }
        }
        
        function handleIdealPartnerQuestion() {
            if (!ensureBaziDataAvailable() || !userInteraction.gender) {
                appendMessage('Please enter your birthday and gender first.', 'bot');
                return;
            }
            if (typeof analyzeIdealPartner === 'function') {
                if (!userInteraction.bazi) {
                    appendMessage('Bazi data is not available. Please re-enter your birthday.', 'bot');
                    return;
                }
                const result = analyzeIdealPartner(userInteraction.bazi, userInteraction.gender);
                if (result) {
                    displayResponseGradually(result);
                } else {
                    appendMessage('Unable to analyze ideal partner. Please try again.', 'bot');
                }
            } else {
                appendMessage('Analysis function not available.', 'bot');
            }
        }
        
        function handleSupportQuestion() {
            if (!ensureBaziDataAvailable()) {
                appendMessage('Please enter your birthday first.', 'bot');
                return;
            }
            if (typeof analyzeSupport === 'function') {
                if (!userInteraction.baziWuxing) {
                    appendMessage('Bazi data is not available. Please re-enter your birthday.', 'bot');
                    return;
                }
                const result = analyzeSupport(userInteraction.baziWuxing);
                if (result) {
                    displayResponseGradually(result);
                } else {
                    appendMessage('Unable to analyze support. Please try again.', 'bot');
                }
            } else {
                appendMessage('Analysis function not available.', 'bot');
            }
        }
        
        function handleOpinionsQuestion() {
            if (!ensureBaziDataAvailable()) {
                appendMessage('Please enter your birthday first.', 'bot');
                return;
            }
            if (typeof analyzeOpinion === 'function') {
                if (!userInteraction.baziWuxing) {
                    appendMessage('Bazi data is not available. Please re-enter your birthday.', 'bot');
                    return;
                }
                const result = analyzeOpinion(userInteraction.baziWuxing);
                if (result) {
                    displayResponseGradually(result);
                } else {
                    appendMessage('Unable to analyze opinions. Please try again.', 'bot');
                }
            } else {
                appendMessage('Analysis function not available.', 'bot');
            }
        }
        
        function handlePurposeQuestion() {
            if (!ensureBaziDataAvailable()) {
                appendMessage('Please enter your birthday first.', 'bot');
                return;
            }
            if (typeof analyzePurpose === 'function') {
                if (!userInteraction.baziWuxing) {
                    appendMessage('Bazi data is not available. Please re-enter your birthday.', 'bot');
                    return;
                }
                const result = analyzePurpose(userInteraction.baziWuxing);
                if (result) {
                    displayResponseGradually(result);
                } else {
                    appendMessage('Unable to analyze purpose. Please try again.', 'bot');
                }
            } else {
                appendMessage('Analysis function not available.', 'bot');
            }
        }
        
        function handleWealthQuestion() {
            if (!ensureBaziDataAvailable()) {
                appendMessage('Please enter your birthday first.', 'bot');
                return;
            }
            if (typeof analyzeWealth === 'function') {
                if (!userInteraction.baziWuxing) {
                    appendMessage('Bazi data is not available. Please re-enter your birthday.', 'bot');
                    return;
                }
                const result = analyzeWealth(userInteraction.baziWuxing);
                if (result) {
                    displayResponseGradually(result);
                } else {
                    appendMessage('Unable to analyze wealth. Please try again.', 'bot');
                }
            } else {
                appendMessage('Analysis function not available.', 'bot');
            }
        }
        
        // Update updateBaziZodiac to use helper functions
        function updateBaziZodiac() {
            if (!userInteraction.birthday) {
                console.warn("LOG: Cannot update Bazi - birthday not set");
                return;
            }
            try {
                console.log("=== DEBUG: updateBaziZodiac 开始 ===");
                console.log("DEBUG: 输入的生日字符串:", userInteraction.birthday);
                
                if (typeof PaiPanFinal !== 'undefined') {
                    const mypaipan = new PaiPanFinal();
                    const dateObject1 = new Date(userInteraction.birthday);
                    console.log("DEBUG: 解析后的日期对象1:", dateObject1.toLocaleString('zh-CN'));
                    
                    const dateObject = adjustTime(dateObject1);
                    console.log("DEBUG: adjustTime 调整后的日期对象:", dateObject.toLocaleString('zh-CN'));
                    console.log("DEBUG: 调整后的年份:", dateObject.getFullYear(), "月份:", dateObject.getMonth() + 1, "日期:", dateObject.getDate());
                    console.log("DEBUG: 调整后的小时:", dateObject.getHours(), "分钟:", dateObject.getMinutes());
                    
                    const baziArray = mypaipan.getBazi(dateObject, true);
                    console.log("DEBUG: getBazi 返回的数组:", baziArray);
                    
                    // Convert array to comma-separated string format expected by other functions
                    // Format: zodiac,年干,年支,月干,月支,日干,日支,时干,时支
                    userInteraction.bazi = baziArray.join(',');
                    console.log("DEBUG: 转换后的八字字符串:", userInteraction.bazi);
                    
                    userInteraction.riyuan = getRiYuan(userInteraction.bazi);
                    userInteraction.yuezhi = getYueZhi(userInteraction.bazi);
                    console.log("DEBUG: 日干 (riyuan):", userInteraction.riyuan);
                    console.log("DEBUG: 月支 (yuezhi):", userInteraction.yuezhi);
                    
                    // Transform to Wuxing
                    if (typeof transformGanZhiToWuXing === 'function') {
                        userInteraction.baziWuxing = transformGanZhiToWuXing(userInteraction.bazi);
                        console.log("DEBUG: 五行 (baziWuxing):", userInteraction.baziWuxing);
                    } else {
                        console.error("LOG: transformGanZhiToWuXing function not available");
                    }
                    
                    const baziFormatted = `${baziArray[1]}${baziArray[2]} ${baziArray[3]}${baziArray[4]} ${baziArray[5]}${baziArray[6]} ${baziArray[7]}${baziArray[8]}`;
                    console.log("DEBUG: 格式化后的八字:", baziFormatted);
                    console.log("LOG: Bazi updated successfully. 此人信息【" + userInteraction.bazi + (userInteraction.baziWuxing || '') + "】");
                    console.log("=== DEBUG: updateBaziZodiac 完成 ===");
                } else {
                    console.warn("PaiPanFinal not available");
                }
            } catch (e) {
                console.error("Error updating Bazi:", e);
                console.error("Error stack:", e.stack);
            }
        }
        
        // Helper function to ensure birthday is available
        function ensureBirthdayAvailable() {
            if (!userInteraction.birthday) {
                // Try to load from localStorage
                const savedBirthday = localStorage.getItem('userBirthday');
                if (savedBirthday) {
                    const [birthday, gender] = savedBirthday.split('.');
                    userInteraction.birthday = birthday;
                    if (gender) {
                        userInteraction.gender = gender;
                    }
                    updateBaziZodiac();
                    return true;
                }
                return false;
            }
            return true;
        }
        
        // Expose handler functions to global scope so they can be called by handleQuestion
        window.handleIOEQuestion = handleIOEQuestion;
        window.handleZodiacQuestion = handleZodiacQuestion;
        window.handleNatureQuestion = handleNatureQuestion;
        window.handleCalmQuestion = handleCalmQuestion;
        window.handleConfidentQuestion = handleConfidentQuestion;
        window.handleAdaptableQuestion = handleAdaptableQuestion;
        window.handleCourageousQuestion = handleCourageousQuestion;
        window.handleCompassionateQuestion = handleCompassionateQuestion;
        window.handlePromisesQuestion = handlePromisesQuestion;
        window.handleMyselfQuestion = handleMyselfQuestion;
        window.handleStrangerQuestion = handleStrangerQuestion;
        window.handleFamiliarQuestion = handleFamiliarQuestion;
        window.handleSexPopularQuestion = handleSexPopularQuestion;
        window.handleIdealPartnerQuestion = handleIdealPartnerQuestion;
        window.handleSupportQuestion = handleSupportQuestion;
        window.handleOpinionsQuestion = handleOpinionsQuestion;
        window.handlePurposeQuestion = handlePurposeQuestion;
        window.handleWealthQuestion = handleWealthQuestion;
        window.handleSwipeQuestion = handleSwipeQuestion;
        
        // --- END: SCRIPT.JS ---
        })(); 
    // 闭合 IIFE
    </script>
</body>
</html>